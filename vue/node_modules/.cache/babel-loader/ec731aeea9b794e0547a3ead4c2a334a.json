{"ast":null,"code":"import { defineComponent, getCurrentInstance, ref, computed, unref, nextTick, onMounted, onUpdated, resolveDynamicComponent, h } from 'vue';\nimport { isNumber, isClient } from '@vueuse/core';\nimport '../../../../utils/index.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport useWheel from '../hooks/use-wheel.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { isHorizontal, getScrollDir, getRTLOffsetType } from '../utils.mjs';\nimport { virtualizedListProps } from '../props.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, BACKWARD, FORWARD, RTL, RTL_OFFSET_POS_DESC, RTL_OFFSET_NAG, AUTO_ALIGNMENT, HORIZONTAL } from '../defaults.mjs';\nimport { hasOwn, isString } from '@vue/shared';\n\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n\n    setup(props, {\n      emit,\n      expose\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const getItemStyleCache = useCache();\n      const windowRef = ref();\n      const innerRef = ref();\n      const scrollbarRef = ref();\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn\n      });\n      const itemsToRender = computed(() => {\n        const {\n          total,\n          cache\n        } = props;\n        const {\n          isScrolling,\n          scrollDir,\n          scrollOffset\n        } = unref(states);\n\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, unref(dynamicSizeCache)));\n\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n\n      const windowStyle = computed(() => [{\n        position: \"relative\",\n        [`overflow-${_isHorizontal.value ? \"x\" : \"y\"}`]: \"scroll\",\n        WebkitOverflowScrolling: \"touch\",\n        willChange: \"transform\"\n      }, {\n        direction: props.direction,\n        height: isNumber(props.height) ? `${props.height}px` : props.height,\n        width: isNumber(props.width) ? `${props.width}px` : props.width\n      }, props.style]);\n      const innerStyle = computed(() => {\n        const size = unref(estimatedTotalSize);\n        const horizontal = unref(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const {\n        onWheel\n      } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, offset => {\n        var _a, _b;\n\n        ;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n\n      const emitEvents = () => {\n        const {\n          total\n        } = props;\n\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n\n        const {\n          scrollDir,\n          scrollOffset,\n          updateRequested\n        } = unref(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n\n      const scrollVertically = e => {\n        const {\n          clientHeight,\n          scrollHeight,\n          scrollTop\n        } = e.currentTarget;\n\n        const _states = unref(states);\n\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = { ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        };\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollHorizontally = e => {\n        const {\n          clientWidth,\n          scrollLeft,\n          scrollWidth\n        } = e.currentTarget;\n\n        const _states = unref(states);\n\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n\n        const {\n          direction\n        } = props;\n        let scrollOffset = scrollLeft;\n\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n\n            case RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = { ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        };\n        nextTick(resetIsScrolling);\n      };\n\n      const onScroll = e => {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n\n      const scrollTo = offset => {\n        offset = Math.max(offset, 0);\n\n        if (offset === unref(states).scrollOffset) {\n          return;\n        }\n\n        states.value = { ...unref(states),\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true\n        };\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const {\n          scrollOffset\n        } = unref(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));\n      };\n\n      const getItemStyle = idx => {\n        const {\n          direction,\n          itemSize,\n          layout\n        } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, unref(dynamicSizeCache));\n          const size = getItemSize(props, idx, unref(dynamicSizeCache));\n          const horizontal = unref(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n\n        return style;\n      };\n\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n\n      const resetScrollTop = () => {\n        const window = windowRef.value;\n\n        if (window) {\n          window.scrollTop = 0;\n        }\n      };\n\n      onMounted(() => {\n        if (!isClient) return;\n        const {\n          initScrollOffset\n        } = props;\n        const windowElement = unref(windowRef);\n\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction,\n          layout\n        } = props;\n        const {\n          scrollOffset,\n          updateRequested\n        } = unref(states);\n        const windowElement = unref(windowRef);\n\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\":\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n\n                case \"positive-ascending\":\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n\n                default:\n                  {\n                    const {\n                      clientWidth,\n                      scrollWidth\n                    } = windowElement;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states\n      });\n      return api;\n    },\n\n    render(ctx) {\n      var _a;\n\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total\n      });\n      const listContainer = h(Container, {\n        class: [\"el-vl__window\", className],\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? {\n        default: () => [InnerNode]\n      } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: [\"el-vl__wrapper\", states.scrollbarAlwaysOn ? \"always-on\" : \"\"]\n      }, [listContainer, scrollbar]);\n    }\n\n  });\n};\n\nexport { createList as default };","map":{"version":3,"mappings":"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","names":["createList","name","getOffset","getItemSize","getItemOffset","getEstimatedTotalSize","getStartIndexForOffset","getStopIndexForStartIndex","initCache","clearCache","validateProps","defineComponent","props","virtualizedListProps","emits","ITEM_RENDER_EVT","SCROLL_EVT","setup","emit","expose","instance","getCurrentInstance","dynamicSizeCache","ref","getItemStyleCache","useCache","windowRef","innerRef","scrollbarRef","states","isScrolling","scrollDir","scrollOffset","isNumber","initScrollOffset","updateRequested","isScrollbarDragging","scrollbarAlwaysOn","itemsToRender","computed","total","cache","unref","startIndex","stopIndex","cacheBackward","BACKWARD","Math","max","cacheForward","FORWARD","min","estimatedTotalSize","_isHorizontal","isHorizontal","layout","windowStyle","position","value","WebkitOverflowScrolling","willChange","direction","height","width","style","innerStyle","size","horizontal","pointerEvents","clientSize","onWheel","useWheel","atStartEdge","atEndEdge","offset","_a","_b","onMouseUp","call","scrollTo","emitEvents","cacheStart","cacheEnd","visibleStart","visibleEnd","scrollVertically","e","clientHeight","scrollHeight","scrollTop","currentTarget","_states","getScrollDir","nextTick","resetIsScrolling","scrollHorizontally","clientWidth","scrollLeft","scrollWidth","RTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","onScroll","onScrollbarScroll","distanceToGo","totalSteps","scrollToItem","idx","alignment","AUTO_ALIGNMENT","getItemStyle","itemSize","itemStyleCache","hasOwn","String","isRtl","offsetHorizontal","left","right","top","resetScrollTop","window","onMounted","isClient","windowElement","onUpdated","HORIZONTAL","api","render","ctx","$slots","className","containerElement","data","innerElement","useIsScrolling","start","end","Container","resolveDynamicComponent","Inner","children","i","push","default","key","index","InnerNode","h","isString","scrollbar","Scrollbar","ratio","scrollFrom","listContainer","class"],"sources":["../../../../../../../packages/components/virtual-list/src/builders/build-list.ts"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  h,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  resolveDynamicComponent,\n  unref,\n} from 'vue'\nimport { isClient } from '@vueuse/core'\nimport { hasOwn, isNumber, isString } from '@element-plus/utils'\nimport { useCache } from '../hooks/use-cache'\nimport useWheel from '../hooks/use-wheel'\nimport Scrollbar from '../components/scrollbar'\nimport { getRTLOffsetType, getScrollDir, isHorizontal } from '../utils'\nimport { virtualizedListProps } from '../props'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  HORIZONTAL,\n  ITEM_RENDER_EVT,\n  RTL,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_DESC,\n  SCROLL_EVT,\n} from '../defaults'\n\nimport type { CSSProperties, Slot, VNode, VNodeChild } from 'vue'\nimport type { Alignment, ListConstructorProps } from '../types'\nimport type { VirtualizedListProps } from '../props'\n\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps,\n}: ListConstructorProps<VirtualizedListProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props)\n      const instance = getCurrentInstance()!\n      const dynamicSizeCache = ref(initCache(props, instance))\n\n      const getItemStyleCache = useCache()\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const innerRef = ref<HTMLElement>()\n      const scrollbarRef = ref()\n      const states = ref({\n        isScrolling: false,\n        scrollDir: 'forward',\n        scrollOffset: isNumber(props.initScrollOffset)\n          ? props.initScrollOffset\n          : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn,\n      })\n\n      // computed\n      const itemsToRender = computed(() => {\n        const { total, cache } = props\n        const { isScrolling, scrollDir, scrollOffset } = unref(states)\n\n        if (total === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getStartIndexForOffset(\n          props,\n          scrollOffset,\n          unref(dynamicSizeCache)\n        )\n        const stopIndex = getStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollOffset,\n          unref(dynamicSizeCache)\n        )\n\n        const cacheBackward =\n          !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1\n        const cacheForward =\n          !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(total! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalSize = computed(() =>\n        getEstimatedTotalSize(props, unref(dynamicSizeCache))\n      )\n\n      const _isHorizontal = computed(() => isHorizontal(props.layout))\n\n      const windowStyle = computed(() => [\n        {\n          position: 'relative',\n          [`overflow-${_isHorizontal.value ? 'x' : 'y'}`]: 'scroll',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style,\n      ])\n\n      const innerStyle = computed(() => {\n        const size = unref(estimatedTotalSize)\n        const horizontal = unref(_isHorizontal)\n        return {\n          height: horizontal ? '100%' : `${size}px`,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width: horizontal ? `${size}px` : '100%',\n        }\n      })\n\n      const clientSize = computed(() =>\n        _isHorizontal.value ? props.width : props.height\n      )\n\n      // methods\n      const { onWheel } = useWheel(\n        {\n          atStartEdge: computed(() => states.value.scrollOffset <= 0),\n          atEndEdge: computed(\n            () => states.value.scrollOffset >= estimatedTotalSize.value\n          ),\n          layout: computed(() => props.layout),\n        },\n        (offset) => {\n          ;(\n            scrollbarRef.value as any as {\n              onMouseUp: () => void\n            }\n          ).onMouseUp?.()\n          scrollTo(\n            Math.min(\n              states.value.scrollOffset + offset,\n              estimatedTotalSize.value - (clientSize.value as number)\n            )\n          )\n        }\n      )\n\n      const emitEvents = () => {\n        const { total } = props\n\n        if (total! > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] =\n            unref(itemsToRender)\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd)\n        }\n\n        const { scrollDir, scrollOffset, updateRequested } = unref(states)\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested)\n      }\n\n      const scrollVertically = (e: Event) => {\n        const { clientHeight, scrollHeight, scrollTop } =\n          e.currentTarget as HTMLElement\n        const _states = unref(states)\n        if (_states.scrollOffset === scrollTop) {\n          return\n        }\n\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        )\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollHorizontally = (e: Event) => {\n        const { clientWidth, scrollLeft, scrollWidth } =\n          e.currentTarget as HTMLElement\n        const _states = unref(states)\n\n        if (_states.scrollOffset === scrollLeft) {\n          return\n        }\n\n        const { direction } = props\n\n        let scrollOffset = scrollLeft\n\n        if (direction === RTL) {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG: {\n              scrollOffset = -scrollLeft\n              break\n            }\n            case RTL_OFFSET_POS_DESC: {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft\n              break\n            }\n          }\n        }\n\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        )\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const onScroll = (e: Event) => {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e)\n        emitEvents()\n      }\n\n      const onScrollbarScroll = (distanceToGo: number, totalSteps: number) => {\n        const offset =\n          ((estimatedTotalSize.value - (clientSize.value as number)) /\n            totalSteps) *\n          distanceToGo\n        scrollTo(\n          Math.min(\n            estimatedTotalSize.value - (clientSize.value as number),\n            offset\n          )\n        )\n      }\n\n      const scrollTo = (offset: number) => {\n        offset = Math.max(offset, 0)\n\n        if (offset === unref(states).scrollOffset) {\n          return\n        }\n\n        states.value = {\n          ...unref(states),\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollToItem = (\n        idx: number,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const { scrollOffset } = unref(states)\n\n        idx = Math.max(0, Math.min(idx, props.total! - 1))\n        scrollTo(\n          getOffset(\n            props,\n            idx,\n            alignment,\n            scrollOffset,\n            unref(dynamicSizeCache)\n          )\n        )\n      }\n\n      const getItemStyle = (idx: number) => {\n        const { direction, itemSize, layout } = props\n\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && itemSize,\n          clearCache && layout,\n          clearCache && direction\n        )\n\n        let style: CSSProperties\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx]\n        } else {\n          const offset = getItemOffset(props, idx, unref(dynamicSizeCache))\n          const size = getItemSize(props, idx, unref(dynamicSizeCache))\n          const horizontal = unref(_isHorizontal)\n\n          const isRtl = direction === RTL\n          const offsetHorizontal = horizontal ? offset : 0\n          itemStyleCache[idx] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : undefined,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : '100%',\n            width: horizontal ? `${size}px` : '100%',\n          }\n        }\n\n        return style\n      }\n\n      // TODO:\n      // perf optimization here, reset isScrolling with debounce.\n\n      const resetIsScrolling = () => {\n        // timer = null\n\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      const resetScrollTop = () => {\n        const window = windowRef.value\n        if (window) {\n          window.scrollTop = 0\n        }\n      }\n\n      // life cycles\n      onMounted(() => {\n        if (!isClient) return\n        const { initScrollOffset } = props\n        const windowElement = unref(windowRef)\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset\n          } else {\n            windowElement.scrollTop = initScrollOffset\n          }\n        }\n\n        emitEvents()\n      })\n\n      onUpdated(() => {\n        const { direction, layout } = props\n        const { scrollOffset, updateRequested } = unref(states)\n        const windowElement = unref(windowRef)\n\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n              // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n              // So we need to determine which browser behavior we're dealing with, and mimic it.\n              switch (getRTLOffsetType()) {\n                case 'negative': {\n                  windowElement.scrollLeft = -scrollOffset\n                  break\n                }\n                case 'positive-ascending': {\n                  windowElement.scrollLeft = scrollOffset\n                  break\n                }\n                default: {\n                  const { clientWidth, scrollWidth } = windowElement\n                  windowElement.scrollLeft =\n                    scrollWidth - clientWidth - scrollOffset\n                  break\n                }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset\n          }\n        }\n      })\n\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n      }\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states,\n      })\n\n      return api\n    },\n\n    render(ctx: any) {\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle,\n      } = ctx\n\n      const [start, end] = itemsToRender\n\n      const Container = resolveDynamicComponent(containerElement)\n      const Inner = resolveDynamicComponent(innerElement)\n\n      const children = [] as VNodeChild[]\n\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push(\n            ($slots.default as Slot)?.({\n              data,\n              key: i,\n              index: i,\n              isScrolling: useIsScrolling ? states.isScrolling : undefined,\n              style: getItemStyle(i),\n            })\n          )\n        }\n      }\n\n      const InnerNode = [\n        h(\n          Inner as VNode,\n          {\n            style: innerStyle,\n            ref: 'innerRef',\n          },\n          !isString(Inner)\n            ? {\n                default: () => children,\n              }\n            : children\n        ),\n      ]\n\n      const scrollbar = h(Scrollbar, {\n        ref: 'scrollbarRef',\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: (clientSize * 100) / this.estimatedTotalSize,\n        scrollFrom:\n          states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n      })\n\n      const listContainer = h(\n        Container as VNode,\n        {\n          class: ['el-vl__window', className],\n          style: windowStyle,\n          onScroll,\n          onWheel,\n          ref: 'windowRef',\n          key: 0,\n        },\n        !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]\n      )\n\n      return h(\n        'div',\n        {\n          key: 0,\n          class: [\n            'el-vl__wrapper',\n            states.scrollbarAlwaysOn ? 'always-on' : '',\n          ],\n        },\n        [listContainer, scrollbar]\n      )\n    },\n  })\n}\n\nexport default createList\n"]},"metadata":{},"sourceType":"module"}