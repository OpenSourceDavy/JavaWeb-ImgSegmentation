{"ast":null,"code":"import { isEqual } from 'lodash-unified';\nimport Node from './node.mjs';\n\nconst flatNodes = (nodes, leafOnly) => {\n  return nodes.reduce((res, node) => {\n    if (node.isLeaf) {\n      res.push(node);\n    } else {\n      !leafOnly && res.push(node);\n      res = res.concat(flatNodes(node.children, leafOnly));\n    }\n\n    return res;\n  }, []);\n};\n\nclass Store {\n  constructor(data, config) {\n    this.config = config;\n    const nodes = (data || []).map(nodeData => new Node(nodeData, this.config));\n    this.nodes = nodes;\n    this.allNodes = flatNodes(nodes, false);\n    this.leafNodes = flatNodes(nodes, true);\n  }\n\n  getNodes() {\n    return this.nodes;\n  }\n\n  getFlattedNodes(leafOnly) {\n    return leafOnly ? this.leafNodes : this.allNodes;\n  }\n\n  appendNode(nodeData, parentNode) {\n    const node = parentNode ? parentNode.appendChild(nodeData) : new Node(nodeData, this.config);\n    if (!parentNode) this.nodes.push(node);\n    this.allNodes.push(node);\n    node.isLeaf && this.leafNodes.push(node);\n  }\n\n  appendNodes(nodeDataList, parentNode) {\n    nodeDataList.forEach(nodeData => this.appendNode(nodeData, parentNode));\n  }\n\n  getNodeByValue(value, leafOnly = false) {\n    if (!value && value !== 0) return null;\n    const node = this.getFlattedNodes(leafOnly).find(node2 => isEqual(node2.value, value) || isEqual(node2.pathValues, value));\n    return node || null;\n  }\n\n  getSameNode(node) {\n    if (!node) return null;\n    const node_ = this.getFlattedNodes(false).find(({\n      value,\n      level\n    }) => isEqual(node.value, value) && node.level === level);\n    return node_ || null;\n  }\n\n}\n\nexport { Store as default };","map":{"version":3,"mappings":";;;AAEA,MAAMA,SAAS,GAAG,CAACC,KAAD,EAAQC,QAAR,KAAqB;AACrC,SAAOD,KAAK,CAACE,MAAN,CAAa,CAACC,GAAD,EAAMC,IAAN,KAAe;AACjC,QAAIA,IAAI,CAACC,MAAT,EAAiB;AACfF,SAAG,CAACG,IAAJ,CAASF,IAAT;AACD,KAFD,MAEO;AACL,OAACH,QAAD,IAAaE,GAAG,CAACG,IAAJ,CAASF,IAAT,CAAb;AACAD,SAAG,GAAGA,GAAG,CAACI,MAAJ,CAAWR,SAAS,CAACK,IAAI,CAACI,QAAN,EAAgBP,QAAhB,CAApB,CAAN;AACD;;AACD,WAAOE,GAAP;AACD,GARM,EAQJ,EARI,CAAP;AASD,CAVD;;AAWe,MAAMM,KAAN,CAAY;AACzBC,aAAW,CAACC,IAAD,EAAOC,MAAP,EAAe;AACxB,SAAKA,MAAL,GAAcA,MAAd;AACA,UAAMZ,KAAK,GAAG,CAACW,IAAI,IAAI,EAAT,EAAaE,GAAb,CAAkBC,QAAD,IAAc,IAAIC,IAAJ,CAASD,QAAT,EAAmB,KAAKF,MAAxB,CAA/B,CAAd;AACA,SAAKZ,KAAL,GAAaA,KAAb;AACA,SAAKgB,QAAL,GAAgBjB,SAAS,CAACC,KAAD,EAAQ,KAAR,CAAzB;AACA,SAAKiB,SAAL,GAAiBlB,SAAS,CAACC,KAAD,EAAQ,IAAR,CAA1B;AACD;;AACDkB,UAAQ,GAAG;AACT,WAAO,KAAKlB,KAAZ;AACD;;AACDmB,iBAAe,CAAClB,QAAD,EAAW;AACxB,WAAOA,QAAQ,GAAG,KAAKgB,SAAR,GAAoB,KAAKD,QAAxC;AACD;;AACDI,YAAU,CAACN,QAAD,EAAWO,UAAX,EAAuB;AAC/B,UAAMjB,IAAI,GAAGiB,UAAU,GAAGA,UAAU,CAACC,WAAX,CAAuBR,QAAvB,CAAH,GAAsC,IAAIC,IAAJ,CAASD,QAAT,EAAmB,KAAKF,MAAxB,CAA7D;AACA,QAAI,CAACS,UAAL,EACE,KAAKrB,KAAL,CAAWM,IAAX,CAAgBF,IAAhB;AACF,SAAKY,QAAL,CAAcV,IAAd,CAAmBF,IAAnB;AACAA,QAAI,CAACC,MAAL,IAAe,KAAKY,SAAL,CAAeX,IAAf,CAAoBF,IAApB,CAAf;AACD;;AACDmB,aAAW,CAACC,YAAD,EAAeH,UAAf,EAA2B;AACpCG,gBAAY,CAACC,OAAb,CAAsBX,QAAD,IAAc,KAAKM,UAAL,CAAgBN,QAAhB,EAA0BO,UAA1B,CAAnC;AACD;;AACDK,gBAAc,CAACC,KAAD,EAAQ1B,QAAQ,GAAG,KAAnB,EAA0B;AACtC,QAAI,CAAC0B,KAAD,IAAUA,KAAK,KAAK,CAAxB,EACE,OAAO,IAAP;AACF,UAAMvB,IAAI,GAAG,KAAKe,eAAL,CAAqBlB,QAArB,EAA+B2B,IAA/B,CAAqCC,KAAD,IAAWC,OAAO,CAACD,KAAK,CAACF,KAAP,EAAcA,KAAd,CAAP,IAA+BG,OAAO,CAACD,KAAK,CAACE,UAAP,EAAmBJ,KAAnB,CAArF,CAAb;AACA,WAAOvB,IAAI,IAAI,IAAf;AACD;;AACD4B,aAAW,CAAC5B,IAAD,EAAO;AAChB,QAAI,CAACA,IAAL,EACE,OAAO,IAAP;AACF,UAAM6B,KAAK,GAAG,KAAKd,eAAL,CAAqB,KAArB,EAA4BS,IAA5B,CAAiC,CAAC;AAAED,WAAF;AAASO;AAAT,KAAD,KAAsBJ,OAAO,CAAC1B,IAAI,CAACuB,KAAN,EAAaA,KAAb,CAAP,IAA8BvB,IAAI,CAAC8B,KAAL,KAAeA,KAApG,CAAd;AACA,WAAOD,KAAK,IAAI,IAAhB;AACD;;AAnCwB","names":["flatNodes","nodes","leafOnly","reduce","res","node","isLeaf","push","concat","children","Store","constructor","data","config","map","nodeData","Node","allNodes","leafNodes","getNodes","getFlattedNodes","appendNode","parentNode","appendChild","appendNodes","nodeDataList","forEach","getNodeByValue","value","find","node2","isEqual","pathValues","getSameNode","node_","level"],"sources":["../../../../../../packages/components/cascader-panel/src/store.ts"],"sourcesContent":["import { isEqual } from 'lodash-unified'\nimport Node from './node'\n\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  CascaderConfig,\n  CascaderNodePathValue,\n  CascaderNodeValue,\n  CascaderOption,\n} from './node'\n\nconst flatNodes = (nodes: Node[], leafOnly: boolean) => {\n  return nodes.reduce((res, node) => {\n    if (node.isLeaf) {\n      res.push(node)\n    } else {\n      !leafOnly && res.push(node)\n      res = res.concat(flatNodes(node.children, leafOnly))\n    }\n    return res\n  }, [] as Node[])\n}\n\nexport default class Store {\n  readonly nodes: Node[]\n  readonly allNodes: Node[]\n  readonly leafNodes: Node[]\n\n  constructor(data: CascaderOption[], readonly config: CascaderConfig) {\n    const nodes = (data || []).map(\n      (nodeData) => new Node(nodeData, this.config)\n    )\n    this.nodes = nodes\n    this.allNodes = flatNodes(nodes, false)\n    this.leafNodes = flatNodes(nodes, true)\n  }\n\n  getNodes() {\n    return this.nodes\n  }\n\n  getFlattedNodes(leafOnly: boolean) {\n    return leafOnly ? this.leafNodes : this.allNodes\n  }\n\n  appendNode(nodeData: CascaderOption, parentNode?: Node) {\n    const node = parentNode\n      ? parentNode.appendChild(nodeData)\n      : new Node(nodeData, this.config)\n\n    if (!parentNode) this.nodes.push(node)\n\n    this.allNodes.push(node)\n    node.isLeaf && this.leafNodes.push(node)\n  }\n\n  appendNodes(nodeDataList: CascaderOption[], parentNode: Node) {\n    nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode))\n  }\n\n  // when checkStrictly, leaf node first\n  getNodeByValue(\n    value: CascaderNodeValue | CascaderNodePathValue,\n    leafOnly = false\n  ): Nullable<Node> {\n    if (!value && value !== 0) return null\n\n    const node = this.getFlattedNodes(leafOnly).find(\n      (node) => isEqual(node.value, value) || isEqual(node.pathValues, value)\n    )\n\n    return node || null\n  }\n\n  getSameNode(node: Node): Nullable<Node> {\n    if (!node) return null\n\n    const node_ = this.getFlattedNodes(false).find(\n      ({ value, level }) => isEqual(node.value, value) && node.level === level\n    )\n\n    return node_ || null\n  }\n}\n"]},"metadata":{},"sourceType":"module"}