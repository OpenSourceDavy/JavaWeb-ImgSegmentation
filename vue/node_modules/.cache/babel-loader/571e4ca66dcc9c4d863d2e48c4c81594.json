{"ast":null,"code":"import '../../../../utils/index.mjs';\nimport Node from './node.mjs';\nimport { getNodeKey } from './util.mjs';\nimport { hasOwn } from '@vue/shared';\n\nclass TreeStore {\n  constructor(options) {\n    this.currentNode = null;\n    this.currentNodeKey = null;\n\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option];\n      }\n    }\n\n    this.nodesMap = {};\n  }\n\n  initialize() {\n    this.root = new Node({\n      data: this.data,\n      store: this\n    });\n    this.root.initialize();\n\n    if (this.lazy && this.load) {\n      const loadFn = this.load;\n      loadFn(this.root, data => {\n        this.root.doCreateChildren(data);\n\n        this._initDefaultCheckedNodes();\n      });\n    } else {\n      this._initDefaultCheckedNodes();\n    }\n  }\n\n  filter(value) {\n    const filterNodeMethod = this.filterNodeMethod;\n    const lazy = this.lazy;\n\n    const traverse = function (node) {\n      const childNodes = node.root ? node.root.childNodes : node.childNodes;\n      childNodes.forEach(child => {\n        child.visible = filterNodeMethod.call(child, value, child.data, child);\n        traverse(child);\n      });\n\n      if (!node.visible && childNodes.length) {\n        let allHidden = true;\n        allHidden = !childNodes.some(child => child.visible);\n\n        if (node.root) {\n          ;\n          node.root.visible = allHidden === false;\n        } else {\n          ;\n          node.visible = allHidden === false;\n        }\n      }\n\n      if (!value) return;\n      if (node.visible && !node.isLeaf && !lazy) node.expand();\n    };\n\n    traverse(this);\n  }\n\n  setData(newVal) {\n    const instanceChanged = newVal !== this.root.data;\n\n    if (instanceChanged) {\n      this.root.setData(newVal);\n\n      this._initDefaultCheckedNodes();\n    } else {\n      this.root.updateChildren();\n    }\n  }\n\n  getNode(data) {\n    if (data instanceof Node) return data;\n    const key = typeof data !== \"object\" ? data : getNodeKey(this.key, data);\n    return this.nodesMap[key] || null;\n  }\n\n  insertBefore(data, refData) {\n    const refNode = this.getNode(refData);\n    refNode.parent.insertBefore({\n      data\n    }, refNode);\n  }\n\n  insertAfter(data, refData) {\n    const refNode = this.getNode(refData);\n    refNode.parent.insertAfter({\n      data\n    }, refNode);\n  }\n\n  remove(data) {\n    const node = this.getNode(data);\n\n    if (node && node.parent) {\n      if (node === this.currentNode) {\n        this.currentNode = null;\n      }\n\n      node.parent.removeChild(node);\n    }\n  }\n\n  append(data, parentData) {\n    const parentNode = parentData ? this.getNode(parentData) : this.root;\n\n    if (parentNode) {\n      parentNode.insertChild({\n        data\n      });\n    }\n  }\n\n  _initDefaultCheckedNodes() {\n    const defaultCheckedKeys = this.defaultCheckedKeys || [];\n    const nodesMap = this.nodesMap;\n    defaultCheckedKeys.forEach(checkedKey => {\n      const node = nodesMap[checkedKey];\n\n      if (node) {\n        node.setChecked(true, !this.checkStrictly);\n      }\n    });\n  }\n\n  _initDefaultCheckedNode(node) {\n    const defaultCheckedKeys = this.defaultCheckedKeys || [];\n\n    if (defaultCheckedKeys.includes(node.key)) {\n      node.setChecked(true, !this.checkStrictly);\n    }\n  }\n\n  setDefaultCheckedKey(newVal) {\n    if (newVal !== this.defaultCheckedKeys) {\n      this.defaultCheckedKeys = newVal;\n\n      this._initDefaultCheckedNodes();\n    }\n  }\n\n  registerNode(node) {\n    const key = this.key;\n    if (!node || !node.data) return;\n\n    if (!key) {\n      this.nodesMap[node.id] = node;\n    } else {\n      const nodeKey = node.key;\n      if (nodeKey !== void 0) this.nodesMap[node.key] = node;\n    }\n  }\n\n  deregisterNode(node) {\n    const key = this.key;\n    if (!key || !node || !node.data) return;\n    node.childNodes.forEach(child => {\n      this.deregisterNode(child);\n    });\n    delete this.nodesMap[node.key];\n  }\n\n  getCheckedNodes(leafOnly = false, includeHalfChecked = false) {\n    const checkedNodes = [];\n\n    const traverse = function (node) {\n      const childNodes = node.root ? node.root.childNodes : node.childNodes;\n      childNodes.forEach(child => {\n        if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {\n          checkedNodes.push(child.data);\n        }\n\n        traverse(child);\n      });\n    };\n\n    traverse(this);\n    return checkedNodes;\n  }\n\n  getCheckedKeys(leafOnly = false) {\n    return this.getCheckedNodes(leafOnly).map(data => (data || {})[this.key]);\n  }\n\n  getHalfCheckedNodes() {\n    const nodes = [];\n\n    const traverse = function (node) {\n      const childNodes = node.root ? node.root.childNodes : node.childNodes;\n      childNodes.forEach(child => {\n        if (child.indeterminate) {\n          nodes.push(child.data);\n        }\n\n        traverse(child);\n      });\n    };\n\n    traverse(this);\n    return nodes;\n  }\n\n  getHalfCheckedKeys() {\n    return this.getHalfCheckedNodes().map(data => (data || {})[this.key]);\n  }\n\n  _getAllNodes() {\n    const allNodes = [];\n    const nodesMap = this.nodesMap;\n\n    for (const nodeKey in nodesMap) {\n      if (hasOwn(nodesMap, nodeKey)) {\n        allNodes.push(nodesMap[nodeKey]);\n      }\n    }\n\n    return allNodes;\n  }\n\n  updateChildren(key, data) {\n    const node = this.nodesMap[key];\n    if (!node) return;\n    const childNodes = node.childNodes;\n\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      const child = childNodes[i];\n      this.remove(child.data);\n    }\n\n    for (let i = 0, j = data.length; i < j; i++) {\n      const child = data[i];\n      this.append(child, node.data);\n    }\n  }\n\n  _setCheckedKeys(key, leafOnly = false, checkedKeys) {\n    const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level);\n\n    const cache = /* @__PURE__ */Object.create(null);\n    const keys = Object.keys(checkedKeys);\n    allNodes.forEach(node => node.setChecked(false, false));\n\n    for (let i = 0, j = allNodes.length; i < j; i++) {\n      const node = allNodes[i];\n      const nodeKey = node.data[key].toString();\n      const checked = keys.includes(nodeKey);\n\n      if (!checked) {\n        if (node.checked && !cache[nodeKey]) {\n          node.setChecked(false, false);\n        }\n\n        continue;\n      }\n\n      let parent = node.parent;\n\n      while (parent && parent.level > 0) {\n        cache[parent.data[key]] = true;\n        parent = parent.parent;\n      }\n\n      if (node.isLeaf || this.checkStrictly) {\n        node.setChecked(true, false);\n        continue;\n      }\n\n      node.setChecked(true, true);\n\n      if (leafOnly) {\n        node.setChecked(false, false);\n\n        const traverse = function (node2) {\n          const childNodes = node2.childNodes;\n          childNodes.forEach(child => {\n            if (!child.isLeaf) {\n              child.setChecked(false, false);\n            }\n\n            traverse(child);\n          });\n        };\n\n        traverse(node);\n      }\n    }\n  }\n\n  setCheckedNodes(array, leafOnly = false) {\n    const key = this.key;\n    const checkedKeys = {};\n    array.forEach(item => {\n      checkedKeys[(item || {})[key]] = true;\n    });\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys);\n  }\n\n  setCheckedKeys(keys, leafOnly = false) {\n    this.defaultCheckedKeys = keys;\n    const key = this.key;\n    const checkedKeys = {};\n    keys.forEach(key2 => {\n      checkedKeys[key2] = true;\n    });\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys);\n  }\n\n  setDefaultExpandedKeys(keys) {\n    keys = keys || [];\n    this.defaultExpandedKeys = keys;\n    keys.forEach(key => {\n      const node = this.getNode(key);\n      if (node) node.expand(null, this.autoExpandParent);\n    });\n  }\n\n  setChecked(data, checked, deep) {\n    const node = this.getNode(data);\n\n    if (node) {\n      node.setChecked(!!checked, deep);\n    }\n  }\n\n  getCurrentNode() {\n    return this.currentNode;\n  }\n\n  setCurrentNode(currentNode) {\n    const prevCurrentNode = this.currentNode;\n\n    if (prevCurrentNode) {\n      prevCurrentNode.isCurrent = false;\n    }\n\n    this.currentNode = currentNode;\n    this.currentNode.isCurrent = true;\n  }\n\n  setUserCurrentNode(node, shouldAutoExpandParent = true) {\n    const key = node[this.key];\n    const currNode = this.nodesMap[key];\n    this.setCurrentNode(currNode);\n\n    if (shouldAutoExpandParent && this.currentNode.level > 1) {\n      this.currentNode.parent.expand(null, true);\n    }\n  }\n\n  setCurrentNodeKey(key, shouldAutoExpandParent = true) {\n    if (key === null || key === void 0) {\n      this.currentNode && (this.currentNode.isCurrent = false);\n      this.currentNode = null;\n      return;\n    }\n\n    const node = this.getNode(key);\n\n    if (node) {\n      this.setCurrentNode(node);\n\n      if (shouldAutoExpandParent && this.currentNode.level > 1) {\n        this.currentNode.parent.expand(null, true);\n      }\n    }\n  }\n\n}\n\nexport { TreeStore as default };","map":{"version":3,"mappings":"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","names":["TreeStore","constructor","options","currentNode","currentNodeKey","option","hasOwn","nodesMap","initialize","root","Node","data","store","lazy","load","loadFn","doCreateChildren","_initDefaultCheckedNodes","filter","value","filterNodeMethod","traverse","node","childNodes","forEach","child","visible","call","length","allHidden","some","isLeaf","expand","setData","newVal","instanceChanged","updateChildren","getNode","key","getNodeKey","insertBefore","refData","refNode","parent","insertAfter","remove","removeChild","append","parentData","parentNode","insertChild","defaultCheckedKeys","checkedKey","setChecked","checkStrictly","_initDefaultCheckedNode","includes","setDefaultCheckedKey","registerNode","id","nodeKey","deregisterNode","getCheckedNodes","leafOnly","includeHalfChecked","checkedNodes","checked","indeterminate","push","getCheckedKeys","map","getHalfCheckedNodes","nodes","getHalfCheckedKeys","_getAllNodes","allNodes","i","j","_setCheckedKeys","checkedKeys","sort","a","b","level","cache","Object","create","keys","toString","node2","setCheckedNodes","array","item","setCheckedKeys","key2","setDefaultExpandedKeys","defaultExpandedKeys","autoExpandParent","deep","getCurrentNode","setCurrentNode","prevCurrentNode","isCurrent","setUserCurrentNode","shouldAutoExpandParent","currNode","setCurrentNodeKey"],"sources":["../../../../../../../packages/components/tree/src/model/tree-store.ts"],"sourcesContent":["import { hasOwn } from '@element-plus/utils'\nimport Node from './node'\nimport { getNodeKey } from './util'\n\nimport type {\n  FilterNodeMethodFunction,\n  FilterValue,\n  LoadFunction,\n  TreeData,\n  TreeKey,\n  TreeNodeData,\n  TreeOptionProps,\n  TreeStoreNodesMap,\n  TreeStoreOptions,\n} from '../tree.type'\n\nexport default class TreeStore {\n  currentNode: Node\n  currentNodeKey: TreeKey\n  nodesMap: TreeStoreNodesMap\n  root: Node\n  data: TreeData\n  lazy: boolean\n  load: LoadFunction\n  filterNodeMethod: FilterNodeMethodFunction\n  key: TreeKey\n  defaultCheckedKeys: TreeKey[]\n  checkStrictly: boolean\n  defaultExpandedKeys: TreeKey[]\n  autoExpandParent: boolean\n  defaultExpandAll: boolean\n  checkDescendants: boolean\n  props: TreeOptionProps\n\n  constructor(options: TreeStoreOptions) {\n    this.currentNode = null\n    this.currentNodeKey = null\n\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option]\n      }\n    }\n\n    this.nodesMap = {}\n  }\n\n  initialize() {\n    this.root = new Node({\n      data: this.data,\n      store: this,\n    })\n    this.root.initialize()\n\n    if (this.lazy && this.load) {\n      const loadFn = this.load\n      loadFn(this.root, (data) => {\n        this.root.doCreateChildren(data)\n        this._initDefaultCheckedNodes()\n      })\n    } else {\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  filter(value: FilterValue): void {\n    const filterNodeMethod = this.filterNodeMethod\n    const lazy = this.lazy\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        child.visible = filterNodeMethod.call(child, value, child.data, child)\n\n        traverse(child)\n      })\n\n      if (!(node as Node).visible && childNodes.length) {\n        let allHidden = true\n        allHidden = !childNodes.some((child) => child.visible)\n\n        if ((node as TreeStore).root) {\n          ;(node as TreeStore).root.visible = allHidden === false\n        } else {\n          ;(node as Node).visible = allHidden === false\n        }\n      }\n      if (!value) return\n\n      if ((node as Node).visible && !(node as Node).isLeaf && !lazy)\n        (node as Node).expand()\n    }\n\n    traverse(this)\n  }\n\n  setData(newVal: TreeData): void {\n    const instanceChanged = newVal !== this.root.data\n    if (instanceChanged) {\n      this.root.setData(newVal)\n      this._initDefaultCheckedNodes()\n    } else {\n      this.root.updateChildren()\n    }\n  }\n\n  getNode(data: TreeKey | TreeNodeData): Node {\n    if (data instanceof Node) return data\n    const key = typeof data !== 'object' ? data : getNodeKey(this.key, data)\n    return this.nodesMap[key] || null\n  }\n\n  insertBefore(data: TreeNodeData, refData: TreeKey | TreeNodeData): void {\n    const refNode = this.getNode(refData)\n    refNode.parent.insertBefore({ data }, refNode)\n  }\n\n  insertAfter(data: TreeNodeData, refData: TreeKey | TreeNodeData): void {\n    const refNode = this.getNode(refData)\n    refNode.parent.insertAfter({ data }, refNode)\n  }\n\n  remove(data: TreeNodeData | Node): void {\n    const node = this.getNode(data)\n\n    if (node && node.parent) {\n      if (node === this.currentNode) {\n        this.currentNode = null\n      }\n      node.parent.removeChild(node)\n    }\n  }\n\n  append(data: TreeNodeData, parentData: TreeNodeData | TreeKey | Node): void {\n    const parentNode = parentData ? this.getNode(parentData) : this.root\n\n    if (parentNode) {\n      parentNode.insertChild({ data })\n    }\n  }\n\n  _initDefaultCheckedNodes(): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n    const nodesMap = this.nodesMap\n\n    defaultCheckedKeys.forEach((checkedKey) => {\n      const node = nodesMap[checkedKey]\n\n      if (node) {\n        node.setChecked(true, !this.checkStrictly)\n      }\n    })\n  }\n\n  _initDefaultCheckedNode(node: Node): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n\n    if (defaultCheckedKeys.includes(node.key)) {\n      node.setChecked(true, !this.checkStrictly)\n    }\n  }\n\n  setDefaultCheckedKey(newVal: TreeKey[]): void {\n    if (newVal !== this.defaultCheckedKeys) {\n      this.defaultCheckedKeys = newVal\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  registerNode(node: Node): void {\n    const key = this.key\n    if (!node || !node.data) return\n\n    if (!key) {\n      this.nodesMap[node.id] = node\n    } else {\n      const nodeKey = node.key\n      if (nodeKey !== undefined) this.nodesMap[node.key] = node\n    }\n  }\n\n  deregisterNode(node: Node): void {\n    const key = this.key\n    if (!key || !node || !node.data) return\n\n    node.childNodes.forEach((child) => {\n      this.deregisterNode(child)\n    })\n\n    delete this.nodesMap[node.key]\n  }\n\n  getCheckedNodes(\n    leafOnly = false,\n    includeHalfChecked = false\n  ): TreeNodeData[] {\n    const checkedNodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (\n          (child.checked || (includeHalfChecked && child.indeterminate)) &&\n          (!leafOnly || (leafOnly && child.isLeaf))\n        ) {\n          checkedNodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return checkedNodes\n  }\n\n  getCheckedKeys(leafOnly = false): TreeKey[] {\n    return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key])\n  }\n\n  getHalfCheckedNodes(): TreeNodeData[] {\n    const nodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (child.indeterminate) {\n          nodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return nodes\n  }\n\n  getHalfCheckedKeys(): TreeKey[] {\n    return this.getHalfCheckedNodes().map((data) => (data || {})[this.key])\n  }\n\n  _getAllNodes(): Node[] {\n    const allNodes: Node[] = []\n    const nodesMap = this.nodesMap\n    for (const nodeKey in nodesMap) {\n      if (hasOwn(nodesMap, nodeKey)) {\n        allNodes.push(nodesMap[nodeKey])\n      }\n    }\n\n    return allNodes\n  }\n\n  updateChildren(key: TreeKey, data: TreeData): void {\n    const node = this.nodesMap[key]\n    if (!node) return\n    const childNodes = node.childNodes\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      const child = childNodes[i]\n      this.remove(child.data)\n    }\n    for (let i = 0, j = data.length; i < j; i++) {\n      const child = data[i]\n      this.append(child, node.data)\n    }\n  }\n\n  _setCheckedKeys(\n    key: TreeKey,\n    leafOnly = false,\n    checkedKeys: { [key: string]: boolean }\n  ): void {\n    const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level)\n    const cache = Object.create(null)\n    const keys = Object.keys(checkedKeys)\n    allNodes.forEach((node) => node.setChecked(false, false))\n    for (let i = 0, j = allNodes.length; i < j; i++) {\n      const node = allNodes[i]\n      const nodeKey = node.data[key].toString()\n      const checked = keys.includes(nodeKey)\n      if (!checked) {\n        if (node.checked && !cache[nodeKey]) {\n          node.setChecked(false, false)\n        }\n        continue\n      }\n\n      let parent = node.parent\n      while (parent && parent.level > 0) {\n        cache[parent.data[key]] = true\n        parent = parent.parent\n      }\n\n      if (node.isLeaf || this.checkStrictly) {\n        node.setChecked(true, false)\n        continue\n      }\n      node.setChecked(true, true)\n\n      if (leafOnly) {\n        node.setChecked(false, false)\n        const traverse = function (node: Node): void {\n          const childNodes = node.childNodes\n          childNodes.forEach((child) => {\n            if (!child.isLeaf) {\n              child.setChecked(false, false)\n            }\n            traverse(child)\n          })\n        }\n        traverse(node)\n      }\n    }\n  }\n\n  setCheckedNodes(array: Node[], leafOnly = false): void {\n    const key = this.key\n    const checkedKeys = {}\n    array.forEach((item) => {\n      checkedKeys[(item || {})[key]] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setCheckedKeys(keys: TreeKey[], leafOnly = false): void {\n    this.defaultCheckedKeys = keys\n    const key = this.key\n    const checkedKeys = {}\n    keys.forEach((key) => {\n      checkedKeys[key] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setDefaultExpandedKeys(keys: TreeKey[]) {\n    keys = keys || []\n    this.defaultExpandedKeys = keys\n    keys.forEach((key) => {\n      const node = this.getNode(key)\n      if (node) node.expand(null, this.autoExpandParent)\n    })\n  }\n\n  setChecked(\n    data: TreeKey | TreeNodeData,\n    checked: boolean,\n    deep: boolean\n  ): void {\n    const node = this.getNode(data)\n\n    if (node) {\n      node.setChecked(!!checked, deep)\n    }\n  }\n\n  getCurrentNode(): Node {\n    return this.currentNode\n  }\n\n  setCurrentNode(currentNode: Node): void {\n    const prevCurrentNode = this.currentNode\n    if (prevCurrentNode) {\n      prevCurrentNode.isCurrent = false\n    }\n    this.currentNode = currentNode\n    this.currentNode.isCurrent = true\n  }\n\n  setUserCurrentNode(node: Node, shouldAutoExpandParent = true): void {\n    const key = node[this.key]\n    const currNode = this.nodesMap[key]\n    this.setCurrentNode(currNode)\n    if (shouldAutoExpandParent && this.currentNode.level > 1) {\n      this.currentNode.parent.expand(null, true)\n    }\n  }\n\n  setCurrentNodeKey(key: TreeKey, shouldAutoExpandParent = true): void {\n    if (key === null || key === undefined) {\n      this.currentNode && (this.currentNode.isCurrent = false)\n      this.currentNode = null\n      return\n    }\n    const node = this.getNode(key)\n    if (node) {\n      this.setCurrentNode(node)\n      if (shouldAutoExpandParent && this.currentNode.level > 1) {\n        this.currentNode.parent.expand(null, true)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}