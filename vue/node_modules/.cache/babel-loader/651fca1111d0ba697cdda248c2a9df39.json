{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { ref, isRef, nextTick } from 'vue';\nimport { isClient } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport { parseHeight } from './util.mjs';\nimport { hasOwn } from '@vue/shared';\n\nclass TableLayout {\n  constructor(options) {\n    this.observers = [];\n    this.table = null;\n    this.store = null;\n    this.columns = [];\n    this.fit = true;\n    this.showHeader = true;\n    this.height = ref(null);\n    this.scrollX = ref(false);\n    this.scrollY = ref(false);\n    this.bodyWidth = ref(null);\n    this.fixedWidth = ref(null);\n    this.rightFixedWidth = ref(null);\n    this.tableHeight = ref(null);\n    this.headerHeight = ref(44);\n    this.appendHeight = ref(0);\n    this.footerHeight = ref(44);\n    this.viewportHeight = ref(null);\n    this.bodyHeight = ref(null);\n    this.bodyScrollHeight = ref(0);\n    this.fixedBodyHeight = ref(null);\n    this.gutterWidth = 0;\n\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        if (isRef(this[name])) {\n          this[name].value = options[name];\n        } else {\n          this[name] = options[name];\n        }\n      }\n    }\n\n    if (!this.table) {\n      throw new Error(\"Table is required for Table Layout\");\n    }\n\n    if (!this.store) {\n      throw new Error(\"Store is required for Table Layout\");\n    }\n  }\n\n  updateScrollY() {\n    const height = this.height.value;\n    if (height === null) return false;\n    const bodyWrapper = this.table.refs.bodyWrapper;\n\n    if (this.table.vnode.el && bodyWrapper) {\n      let scrollY = true;\n      const prevScrollY = this.scrollY.value;\n\n      if (this.bodyHeight.value === null) {\n        scrollY = false;\n      } else {\n        scrollY = bodyWrapper.scrollHeight > this.bodyHeight.value;\n      }\n\n      this.scrollY.value = scrollY;\n      return prevScrollY !== scrollY;\n    }\n\n    return false;\n  }\n\n  setHeight(value, prop = \"height\") {\n    if (!isClient) return;\n    const el = this.table.vnode.el;\n    value = parseHeight(value);\n    this.height.value = Number(value);\n    if (!el && (value || value === 0)) return nextTick(() => this.setHeight(value, prop));\n\n    if (typeof value === \"number\") {\n      el.style[prop] = `${value}px`;\n      this.updateElsHeight();\n    } else if (typeof value === \"string\") {\n      el.style[prop] = value;\n      this.updateElsHeight();\n    }\n  }\n\n  setMaxHeight(value) {\n    this.setHeight(value, \"max-height\");\n  }\n\n  getFlattenColumns() {\n    const flattenColumns = [];\n    const columns = this.table.store.states.columns.value;\n    columns.forEach(column => {\n      if (column.isColumnGroup) {\n        flattenColumns.push.apply(flattenColumns, column.columns);\n      } else {\n        flattenColumns.push(column);\n      }\n    });\n    return flattenColumns;\n  }\n\n  updateElsHeight() {\n    var _a, _b;\n\n    if (!this.table.$ready) return nextTick(() => this.updateElsHeight());\n    const {\n      tableWrapper,\n      headerWrapper,\n      appendWrapper,\n      footerWrapper,\n      tableHeader,\n      tableBody\n    } = this.table.refs;\n\n    if (tableWrapper && tableWrapper.style.display === \"none\") {\n      return;\n    }\n\n    const {\n      tableLayout\n    } = this.table.props;\n    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;\n\n    if (this.showHeader && !headerWrapper && tableLayout === \"fixed\") {\n      return;\n    }\n\n    const headerTrElm = tableHeader ? tableHeader : null;\n    const noneHeader = this.headerDisplayNone(headerTrElm);\n    const headerWrapperOffsetHeight = (headerWrapper == null ? void 0 : headerWrapper.offsetHeight) || 0;\n    const headerHeight = this.headerHeight.value = !this.showHeader ? 0 : headerWrapperOffsetHeight;\n\n    if (this.showHeader && !noneHeader && headerWrapperOffsetHeight > 0 && (this.table.store.states.columns.value || []).length > 0 && headerHeight < 2) {\n      return nextTick(() => this.updateElsHeight());\n    }\n\n    const tableHeight = this.tableHeight.value = (_b = (_a = this.table) == null ? void 0 : _a.vnode.el) == null ? void 0 : _b.clientHeight;\n    const footerHeight = this.footerHeight.value = footerWrapper ? footerWrapper.offsetHeight : 0;\n\n    if (this.height.value !== null) {\n      if (this.bodyHeight.value === null) {\n        requestAnimationFrame(() => this.updateElsHeight());\n      }\n\n      this.bodyHeight.value = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);\n      this.bodyScrollHeight.value = tableBody == null ? void 0 : tableBody.scrollHeight;\n    }\n\n    this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value;\n    this.viewportHeight.value = this.scrollX.value ? tableHeight - this.gutterWidth : tableHeight;\n    this.updateScrollY();\n    this.notifyObservers(\"scrollable\");\n  }\n\n  headerDisplayNone(elm) {\n    if (!elm) return true;\n    let headerChild = elm;\n\n    while (headerChild.tagName !== \"DIV\") {\n      if (getComputedStyle(headerChild).display === \"none\") {\n        return true;\n      }\n\n      headerChild = headerChild.parentElement;\n    }\n\n    return false;\n  }\n\n  updateColumnsWidth() {\n    if (!isClient) return;\n    const fit = this.fit;\n    const bodyWidth = this.table.vnode.el.clientWidth;\n    let bodyMinWidth = 0;\n    const flattenColumns = this.getFlattenColumns();\n    const flexColumns = flattenColumns.filter(column => typeof column.width !== \"number\");\n    flattenColumns.forEach(column => {\n      if (typeof column.width === \"number\" && column.realWidth) column.realWidth = null;\n    });\n\n    if (flexColumns.length > 0 && fit) {\n      flattenColumns.forEach(column => {\n        bodyMinWidth += Number(column.width || column.minWidth || 80);\n      });\n\n      if (bodyMinWidth <= bodyWidth) {\n        this.scrollX.value = false;\n        const totalFlexWidth = bodyWidth - bodyMinWidth;\n\n        if (flexColumns.length === 1) {\n          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;\n        } else {\n          const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);\n          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;\n          let noneFirstWidth = 0;\n          flexColumns.forEach((column, index) => {\n            if (index === 0) return;\n            const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);\n            noneFirstWidth += flexWidth;\n            column.realWidth = Number(column.minWidth || 80) + flexWidth;\n          });\n          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;\n        }\n      } else {\n        this.scrollX.value = true;\n        flexColumns.forEach(column => {\n          column.realWidth = Number(column.minWidth);\n        });\n      }\n\n      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);\n      this.table.state.resizeState.value.width = this.bodyWidth.value;\n    } else {\n      flattenColumns.forEach(column => {\n        if (!column.width && !column.minWidth) {\n          column.realWidth = 80;\n        } else {\n          column.realWidth = Number(column.width || column.minWidth);\n        }\n\n        bodyMinWidth += column.realWidth;\n      });\n      this.scrollX.value = bodyMinWidth > bodyWidth;\n      this.bodyWidth.value = bodyMinWidth;\n    }\n\n    const fixedColumns = this.store.states.fixedColumns.value;\n\n    if (fixedColumns.length > 0) {\n      let fixedWidth = 0;\n      fixedColumns.forEach(column => {\n        fixedWidth += Number(column.realWidth || column.width);\n      });\n      this.fixedWidth.value = fixedWidth;\n    }\n\n    const rightFixedColumns = this.store.states.rightFixedColumns.value;\n\n    if (rightFixedColumns.length > 0) {\n      let rightFixedWidth = 0;\n      rightFixedColumns.forEach(column => {\n        rightFixedWidth += Number(column.realWidth || column.width);\n      });\n      this.rightFixedWidth.value = rightFixedWidth;\n    }\n\n    this.notifyObservers(\"columns\");\n  }\n\n  addObserver(observer) {\n    this.observers.push(observer);\n  }\n\n  removeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  notifyObservers(event) {\n    const observers = this.observers;\n    observers.forEach(observer => {\n      var _a, _b;\n\n      switch (event) {\n        case \"columns\":\n          (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);\n          break;\n\n        case \"scrollable\":\n          (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);\n          break;\n\n        default:\n          throw new Error(`Table Layout don't have event ${event}.`);\n      }\n    });\n  }\n\n}\n\nexport { TableLayout as default };","map":{"version":3,"mappings":"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","names":["TableLayout","constructor","options","observers","table","store","columns","fit","showHeader","height","ref","scrollX","scrollY","bodyWidth","fixedWidth","rightFixedWidth","tableHeight","headerHeight","appendHeight","footerHeight","viewportHeight","bodyHeight","bodyScrollHeight","fixedBodyHeight","gutterWidth","name","hasOwn","isRef","value","Error","updateScrollY","bodyWrapper","refs","vnode","el","prevScrollY","scrollHeight","setHeight","prop","isClient","parseHeight","Number","nextTick","style","updateElsHeight","setMaxHeight","getFlattenColumns","flattenColumns","states","forEach","column","isColumnGroup","push","apply","_a","_b","$ready","tableWrapper","headerWrapper","appendWrapper","footerWrapper","tableHeader","tableBody","display","tableLayout","props","offsetHeight","headerTrElm","noneHeader","headerDisplayNone","headerWrapperOffsetHeight","length","clientHeight","requestAnimationFrame","notifyObservers","elm","headerChild","tagName","getComputedStyle","parentElement","updateColumnsWidth","clientWidth","bodyMinWidth","flexColumns","filter","width","realWidth","minWidth","totalFlexWidth","allColumnsWidth","reduce","prev","flexWidthPerPixel","noneFirstWidth","index","flexWidth","Math","floor","max","state","resizeState","fixedColumns","rightFixedColumns","addObserver","observer","removeObserver","indexOf","splice","event","onColumnsChange","onScrollableChange"],"sources":["../../../../../../packages/components/table/src/table-layout.ts"],"sourcesContent":["import { isRef, nextTick, ref } from 'vue'\nimport { isClient } from '@vueuse/core'\nimport { hasOwn } from '@element-plus/utils'\nimport { parseHeight } from './util'\nimport type { Ref } from 'vue'\n\nimport type { TableColumnCtx } from './table-column/defaults'\nimport type { TableHeader } from './table-header'\nimport type { Table } from './table/defaults'\nimport type { Store } from './store'\nclass TableLayout<T> {\n  observers: TableHeader[]\n  table: Table<T>\n  store: Store<T>\n  columns: TableColumnCtx<T>[]\n  fit: boolean\n  showHeader: boolean\n\n  height: Ref<null | number>\n  scrollX: Ref<boolean>\n  scrollY: Ref<boolean>\n  bodyWidth: Ref<null | number>\n  fixedWidth: Ref<null | number>\n  rightFixedWidth: Ref<null | number>\n  tableHeight: Ref<null | number>\n  headerHeight: Ref<null | number> // Table Header Height\n  appendHeight: Ref<null | number> // Append Slot Height\n  footerHeight: Ref<null | number> // Table Footer Height\n  viewportHeight: Ref<null | number> // Table Height - Scroll Bar Height\n  bodyHeight: Ref<null | number> // Table Height - Table Header Height\n  bodyScrollHeight: Ref<number>\n  fixedBodyHeight: Ref<null | number> // Table Height - Table Header Height - Scroll Bar Height\n  gutterWidth: number\n  constructor(options: Record<string, any>) {\n    this.observers = []\n    this.table = null\n    this.store = null\n    this.columns = []\n    this.fit = true\n    this.showHeader = true\n    this.height = ref(null)\n    this.scrollX = ref(false)\n    this.scrollY = ref(false)\n    this.bodyWidth = ref(null)\n    this.fixedWidth = ref(null)\n    this.rightFixedWidth = ref(null)\n    this.tableHeight = ref(null)\n    this.headerHeight = ref(44)\n    this.appendHeight = ref(0)\n    this.footerHeight = ref(44)\n    this.viewportHeight = ref(null)\n    this.bodyHeight = ref(null)\n    this.bodyScrollHeight = ref(0)\n    this.fixedBodyHeight = ref(null)\n    this.gutterWidth = 0\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        if (isRef(this[name])) {\n          this[name as string].value = options[name]\n        } else {\n          this[name as string] = options[name]\n        }\n      }\n    }\n    if (!this.table) {\n      throw new Error('Table is required for Table Layout')\n    }\n    if (!this.store) {\n      throw new Error('Store is required for Table Layout')\n    }\n  }\n\n  updateScrollY() {\n    const height = this.height.value\n    /**\n     * When the height is not initialized, it is null.\n     * After the table is initialized, when the height is not configured, the height is 0.\n     */\n    if (height === null) return false\n    const bodyWrapper = this.table.refs.bodyWrapper as HTMLElement\n    if (this.table.vnode.el && bodyWrapper) {\n      let scrollY = true\n      const prevScrollY = this.scrollY.value\n      /**\n       * When bodyHeight has no value,\n       * it means that the table height is not set,\n       * and the scroll bar will never appear\n       */\n      if (this.bodyHeight.value === null) {\n        scrollY = false\n      } else {\n        scrollY = bodyWrapper.scrollHeight > this.bodyHeight.value\n      }\n      this.scrollY.value = scrollY\n      return prevScrollY !== scrollY\n    }\n    return false\n  }\n\n  setHeight(value: string | number, prop = 'height') {\n    if (!isClient) return\n    const el = this.table.vnode.el\n    value = parseHeight(value)\n    this.height.value = Number(value)\n\n    if (!el && (value || value === 0))\n      return nextTick(() => this.setHeight(value, prop))\n\n    if (typeof value === 'number') {\n      el.style[prop] = `${value}px`\n      this.updateElsHeight()\n    } else if (typeof value === 'string') {\n      el.style[prop] = value\n      this.updateElsHeight()\n    }\n  }\n\n  setMaxHeight(value: string | number) {\n    this.setHeight(value, 'max-height')\n  }\n\n  getFlattenColumns(): TableColumnCtx<T>[] {\n    const flattenColumns = []\n    const columns = this.table.store.states.columns.value\n    columns.forEach((column) => {\n      if (column.isColumnGroup) {\n        // eslint-disable-next-line prefer-spread\n        flattenColumns.push.apply(flattenColumns, column.columns)\n      } else {\n        flattenColumns.push(column)\n      }\n    })\n\n    return flattenColumns\n  }\n\n  updateElsHeight() {\n    if (!this.table.$ready) return nextTick(() => this.updateElsHeight())\n    const {\n      tableWrapper,\n      headerWrapper,\n      appendWrapper,\n      footerWrapper,\n      tableHeader,\n      tableBody,\n    } = this.table.refs\n    if (tableWrapper && tableWrapper.style.display === 'none') {\n      // avoid v-show\n      return\n    }\n    const { tableLayout } = this.table.props\n    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0\n    if (this.showHeader && !headerWrapper && tableLayout === 'fixed') {\n      return\n    }\n    const headerTrElm: HTMLElement = tableHeader ? tableHeader : null\n    const noneHeader = this.headerDisplayNone(headerTrElm)\n    const headerWrapperOffsetHeight = headerWrapper?.offsetHeight || 0\n    const headerHeight = (this.headerHeight.value = !this.showHeader\n      ? 0\n      : headerWrapperOffsetHeight)\n    if (\n      this.showHeader &&\n      !noneHeader &&\n      headerWrapperOffsetHeight > 0 &&\n      (this.table.store.states.columns.value || []).length > 0 &&\n      headerHeight < 2\n    ) {\n      return nextTick(() => this.updateElsHeight())\n    }\n    const tableHeight = (this.tableHeight.value =\n      this.table?.vnode.el?.clientHeight)\n    const footerHeight = (this.footerHeight.value = footerWrapper\n      ? footerWrapper.offsetHeight\n      : 0)\n    if (this.height.value !== null) {\n      if (this.bodyHeight.value === null) {\n        requestAnimationFrame(() => this.updateElsHeight())\n      }\n      this.bodyHeight.value =\n        tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0)\n      this.bodyScrollHeight.value = tableBody?.scrollHeight\n    }\n    this.fixedBodyHeight.value = this.scrollX.value\n      ? this.bodyHeight.value - this.gutterWidth\n      : this.bodyHeight.value\n\n    this.viewportHeight.value = this.scrollX.value\n      ? tableHeight - this.gutterWidth\n      : tableHeight\n\n    this.updateScrollY()\n    this.notifyObservers('scrollable')\n  }\n\n  headerDisplayNone(elm: HTMLElement) {\n    if (!elm) return true\n    let headerChild = elm\n    while (headerChild.tagName !== 'DIV') {\n      if (getComputedStyle(headerChild).display === 'none') {\n        return true\n      }\n      headerChild = headerChild.parentElement\n    }\n    return false\n  }\n\n  updateColumnsWidth() {\n    if (!isClient) return\n    const fit = this.fit\n    const bodyWidth = this.table.vnode.el.clientWidth\n    let bodyMinWidth = 0\n\n    const flattenColumns = this.getFlattenColumns()\n    const flexColumns = flattenColumns.filter(\n      (column) => typeof column.width !== 'number'\n    )\n    flattenColumns.forEach((column) => {\n      // Clean those columns whose width changed from flex to unflex\n      if (typeof column.width === 'number' && column.realWidth)\n        column.realWidth = null\n    })\n    if (flexColumns.length > 0 && fit) {\n      flattenColumns.forEach((column) => {\n        bodyMinWidth += Number(column.width || column.minWidth || 80)\n      })\n      if (bodyMinWidth <= bodyWidth) {\n        // DON'T HAVE SCROLL BAR\n        this.scrollX.value = false\n\n        const totalFlexWidth = bodyWidth - bodyMinWidth\n\n        if (flexColumns.length === 1) {\n          flexColumns[0].realWidth =\n            Number(flexColumns[0].minWidth || 80) + totalFlexWidth\n        } else {\n          const allColumnsWidth = flexColumns.reduce(\n            (prev, column) => prev + Number(column.minWidth || 80),\n            0\n          )\n          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth\n          let noneFirstWidth = 0\n\n          flexColumns.forEach((column, index) => {\n            if (index === 0) return\n            const flexWidth = Math.floor(\n              Number(column.minWidth || 80) * flexWidthPerPixel\n            )\n            noneFirstWidth += flexWidth\n            column.realWidth = Number(column.minWidth || 80) + flexWidth\n          })\n\n          flexColumns[0].realWidth =\n            Number(flexColumns[0].minWidth || 80) +\n            totalFlexWidth -\n            noneFirstWidth\n        }\n      } else {\n        // HAVE HORIZONTAL SCROLL BAR\n        this.scrollX.value = true\n        flexColumns.forEach((column) => {\n          column.realWidth = Number(column.minWidth)\n        })\n      }\n\n      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth)\n      this.table.state.resizeState.value.width = this.bodyWidth.value\n    } else {\n      flattenColumns.forEach((column) => {\n        if (!column.width && !column.minWidth) {\n          column.realWidth = 80\n        } else {\n          column.realWidth = Number(column.width || column.minWidth)\n        }\n        bodyMinWidth += column.realWidth\n      })\n      this.scrollX.value = bodyMinWidth > bodyWidth\n\n      this.bodyWidth.value = bodyMinWidth\n    }\n\n    const fixedColumns = this.store.states.fixedColumns.value\n\n    if (fixedColumns.length > 0) {\n      let fixedWidth = 0\n      fixedColumns.forEach((column) => {\n        fixedWidth += Number(column.realWidth || column.width)\n      })\n\n      this.fixedWidth.value = fixedWidth\n    }\n\n    const rightFixedColumns = this.store.states.rightFixedColumns.value\n    if (rightFixedColumns.length > 0) {\n      let rightFixedWidth = 0\n      rightFixedColumns.forEach((column) => {\n        rightFixedWidth += Number(column.realWidth || column.width)\n      })\n\n      this.rightFixedWidth.value = rightFixedWidth\n    }\n    this.notifyObservers('columns')\n  }\n\n  addObserver(observer: TableHeader) {\n    this.observers.push(observer)\n  }\n\n  removeObserver(observer: TableHeader) {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.observers.splice(index, 1)\n    }\n  }\n\n  notifyObservers(event: string) {\n    const observers = this.observers\n    observers.forEach((observer) => {\n      switch (event) {\n        case 'columns':\n          observer.state?.onColumnsChange(this)\n          break\n        case 'scrollable':\n          observer.state?.onScrollableChange(this)\n          break\n        default:\n          throw new Error(`Table Layout don't have event ${event}.`)\n      }\n    })\n  }\n}\n\nexport default TableLayout\n"]},"metadata":{},"sourceType":"module"}