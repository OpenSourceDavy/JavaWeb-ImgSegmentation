{"ast":null,"code":"import { defineComponent, getCurrentInstance, shallowRef, ref, watch, onMounted, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle } from 'vue';\nimport '../../../../utils/index.mjs';\nimport draggable from '../draggable.mjs';\nimport _export_sfc from '../../../../_virtual/plugin-vue_export-helper.mjs';\nimport { getClientXY } from '../../../../utils/dom/position.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"ElColorAlphaSlider\",\n  props: {\n    color: {\n      type: Object,\n      required: true\n    },\n    vertical: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  setup(props) {\n    const instance = getCurrentInstance();\n    const thumb = shallowRef(null);\n    const bar = shallowRef(null);\n    const thumbLeft = ref(0);\n    const thumbTop = ref(0);\n    const background = ref(null);\n    watch(() => props.color.get(\"alpha\"), () => {\n      update();\n    });\n    watch(() => props.color.value, () => {\n      update();\n    });\n\n    function getThumbLeft() {\n      if (props.vertical) return 0;\n      const el = instance.vnode.el;\n      const alpha = props.color.get(\"alpha\");\n      if (!el) return 0;\n      return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);\n    }\n\n    function getThumbTop() {\n      const el = instance.vnode.el;\n      if (!props.vertical) return 0;\n      const alpha = props.color.get(\"alpha\");\n      if (!el) return 0;\n      return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);\n    }\n\n    function getBackground() {\n      if (props.color && props.color.value) {\n        const {\n          r,\n          g,\n          b\n        } = props.color.toRgb();\n        return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;\n      }\n\n      return null;\n    }\n\n    function handleClick(event) {\n      const target = event.target;\n\n      if (target !== thumb.value) {\n        handleDrag(event);\n      }\n    }\n\n    function handleDrag(event) {\n      const el = instance.vnode.el;\n      const rect = el.getBoundingClientRect();\n      const {\n        clientX,\n        clientY\n      } = getClientXY(event);\n\n      if (!props.vertical) {\n        let left = clientX - rect.left;\n        left = Math.max(thumb.value.offsetWidth / 2, left);\n        left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);\n        props.color.set(\"alpha\", Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));\n      } else {\n        let top = clientY - rect.top;\n        top = Math.max(thumb.value.offsetHeight / 2, top);\n        top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);\n        props.color.set(\"alpha\", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));\n      }\n    }\n\n    function update() {\n      thumbLeft.value = getThumbLeft();\n      thumbTop.value = getThumbTop();\n      background.value = getBackground();\n    }\n\n    onMounted(() => {\n      const dragConfig = {\n        drag: event => {\n          handleDrag(event);\n        },\n        end: event => {\n          handleDrag(event);\n        }\n      };\n      draggable(bar.value, dragConfig);\n      draggable(thumb.value, dragConfig);\n      update();\n    });\n    return {\n      thumb,\n      bar,\n      thumbLeft,\n      thumbTop,\n      background,\n      handleClick,\n      update\n    };\n  }\n\n});\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass([\"el-color-alpha-slider\", {\n      \"is-vertical\": _ctx.vertical\n    }])\n  }, [createElementVNode(\"div\", {\n    ref: \"bar\",\n    class: \"el-color-alpha-slider__bar\",\n    style: normalizeStyle({\n      background: _ctx.background\n    }),\n    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))\n  }, null, 4), createElementVNode(\"div\", {\n    ref: \"thumb\",\n    class: \"el-color-alpha-slider__thumb\",\n    style: normalizeStyle({\n      left: _ctx.thumbLeft + \"px\",\n      top: _ctx.thumbTop + \"px\"\n    })\n  }, null, 4)], 2);\n}\n\nvar AlphaSlider = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/alpha-slider.vue\"]]);\n\nexport { AlphaSlider as default };","map":{"version":3,"mappings":"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","names":["_sfc_main","defineComponent","name","props","color","type","required","vertical","default","setup","instance","getCurrentInstance","shallowRef","ref","watch","get","update","value","vnode","el","alpha","round","offsetWidth","thumb","offsetHeight","r","g","b","toRgb","event","target","handleDrag","getBoundingClientRect","clientX","clientY","getClientXY","rect","left","Math","max","min","width","set","top","height","thumbLeft","getThumbLeft","thumbTop","getThumbTop","background","getBackground","onMounted","dragConfig","drag","end","draggable","bar","handleClick","_createElementBlock","class","_ctx","_createElementVNode","style","onClick","_cache"],"sources":["../../../../../../../packages/components/color-picker/src/components/alpha-slider.vue"],"sourcesContent":["<template>\n  <div class=\"el-color-alpha-slider\" :class=\"{ 'is-vertical': vertical }\">\n    <div\n      ref=\"bar\"\n      class=\"el-color-alpha-slider__bar\"\n      :style=\"{\n        background,\n      }\"\n      @click=\"handleClick\"\n    />\n    <div\n      ref=\"thumb\"\n      class=\"el-color-alpha-slider__thumb\"\n      :style=\"{\n        left: thumbLeft + 'px',\n        top: thumbTop + 'px',\n      }\"\n    />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  getCurrentInstance,\n  onMounted,\n  ref,\n  shallowRef,\n  watch,\n} from 'vue'\nimport { getClientXY } from '@element-plus/utils'\nimport draggable from '../draggable'\n\nimport type { PropType } from 'vue'\nimport type { Nullable } from '@element-plus/utils'\nimport type Color from '../color'\n\nexport default defineComponent({\n  name: 'ElColorAlphaSlider',\n  props: {\n    color: {\n      type: Object as PropType<Color>,\n      required: true,\n    },\n    vertical: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props) {\n    const instance = getCurrentInstance()\n    // ref\n    const thumb = shallowRef<Nullable<HTMLElement>>(null)\n    const bar = shallowRef<Nullable<HTMLElement>>(null)\n\n    // data\n    const thumbLeft = ref(0)\n    const thumbTop = ref(0)\n    const background = ref<Nullable<string>>(null)\n\n    watch(\n      () => props.color.get('alpha'),\n      () => {\n        update()\n      }\n    )\n    watch(\n      () => props.color.value,\n      () => {\n        update()\n      }\n    )\n\n    //methods\n    function getThumbLeft() {\n      if (props.vertical) return 0\n      const el = instance.vnode.el\n      const alpha = props.color.get('alpha')\n\n      if (!el) return 0\n      return Math.round(\n        (alpha * (el.offsetWidth - thumb.value.offsetWidth / 2)) / 100\n      )\n    }\n\n    function getThumbTop() {\n      const el = instance.vnode.el\n      if (!props.vertical) return 0\n      const alpha = props.color.get('alpha')\n\n      if (!el) return 0\n      return Math.round(\n        (alpha * (el.offsetHeight - thumb.value.offsetHeight / 2)) / 100\n      )\n    }\n\n    function getBackground() {\n      if (props.color && props.color.value) {\n        const { r, g, b } = props.color.toRgb()\n        return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`\n      }\n      return null\n    }\n\n    function handleClick(event: Event) {\n      const target = event.target\n\n      if (target !== thumb.value) {\n        handleDrag(event)\n      }\n    }\n\n    function handleDrag(event) {\n      const el = instance.vnode.el as HTMLElement\n      const rect = el.getBoundingClientRect()\n      const { clientX, clientY } = getClientXY(event)\n\n      if (!props.vertical) {\n        let left = clientX - rect.left\n        left = Math.max(thumb.value.offsetWidth / 2, left)\n        left = Math.min(left, rect.width - thumb.value.offsetWidth / 2)\n\n        props.color.set(\n          'alpha',\n          Math.round(\n            ((left - thumb.value.offsetWidth / 2) /\n              (rect.width - thumb.value.offsetWidth)) *\n              100\n          )\n        )\n      } else {\n        let top = clientY - rect.top\n        top = Math.max(thumb.value.offsetHeight / 2, top)\n        top = Math.min(top, rect.height - thumb.value.offsetHeight / 2)\n\n        props.color.set(\n          'alpha',\n          Math.round(\n            ((top - thumb.value.offsetHeight / 2) /\n              (rect.height - thumb.value.offsetHeight)) *\n              100\n          )\n        )\n      }\n    }\n\n    function update() {\n      thumbLeft.value = getThumbLeft()\n      thumbTop.value = getThumbTop()\n      background.value = getBackground()\n    }\n\n    // mounded\n    onMounted(() => {\n      const dragConfig = {\n        drag: (event) => {\n          handleDrag(event)\n        },\n        end: (event) => {\n          handleDrag(event)\n        },\n      }\n\n      draggable(bar.value, dragConfig)\n      draggable(thumb.value, dragConfig)\n      update()\n    })\n\n    return {\n      thumb,\n      bar,\n      thumbLeft,\n      thumbTop,\n      background,\n      handleClick,\n      update,\n    }\n  },\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}