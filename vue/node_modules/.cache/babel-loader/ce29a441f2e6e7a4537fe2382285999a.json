{"ast":null,"code":"import { defineComponent, inject, ref, computed, watch, onMounted, onUpdated, createVNode } from 'vue';\nimport { NOOP, capitalize } from '@vue/shared';\nimport { useDocumentVisibility, useWindowFocus, useResizeObserver } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../constants/index.mjs';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue';\nimport '../../../tokens/index.mjs';\nimport '../../../hooks/index.mjs';\nimport TabBar from './tab-bar2.mjs';\nimport { buildProps, definePropType } from '../../../utils/vue/props.mjs';\nimport { mutable } from '../../../utils/typescript.mjs';\nimport { tabsRootContextKey } from '../../../tokens/tabs.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nconst tabNavProps = buildProps({\n  panes: {\n    type: definePropType(Array),\n    default: () => mutable([])\n  },\n  currentName: {\n    type: [String, Number],\n    default: \"\"\n  },\n  editable: Boolean,\n  onTabClick: {\n    type: definePropType(Function),\n    default: NOOP\n  },\n  onTabRemove: {\n    type: definePropType(Function),\n    default: NOOP\n  },\n  type: {\n    type: String,\n    values: [\"card\", \"border-card\", \"\"],\n    default: \"\"\n  },\n  stretch: Boolean\n});\nconst COMPONENT_NAME = \"ElTabNav\";\nconst TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n\n  setup(props, {\n    expose\n  }) {\n    const rootTabs = inject(tabsRootContextKey);\n    if (!rootTabs) throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`);\n    const ns = useNamespace(\"tabs\");\n    const visibility = useDocumentVisibility();\n    const focused = useWindowFocus();\n    const navScroll$ = ref();\n    const nav$ = ref();\n    const el$ = ref();\n    const scrollable = ref(false);\n    const navOffset = ref(0);\n    const isFocus = ref(false);\n    const focusable = ref(true);\n    const sizeName = computed(() => [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition) ? \"width\" : \"height\");\n    const navStyle = computed(() => {\n      const dir = sizeName.value === \"width\" ? \"X\" : \"Y\";\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`\n      };\n    });\n\n    const scrollPrev = () => {\n      if (!navScroll$.value) return;\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (!currentOffset) return;\n      const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n      navOffset.value = newOffset;\n    };\n\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return;\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (navSize - currentOffset <= containerSize) return;\n      const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;\n      navOffset.value = newOffset;\n    };\n\n    const scrollToActiveTab = () => {\n      const nav = nav$.value;\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return;\n      const activeTab = el$.value.querySelector(\".is-active\");\n      if (!activeTab) return;\n      const navScroll = navScroll$.value;\n      const isHorizontal = [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition);\n      const activeTabBounding = activeTab.getBoundingClientRect();\n      const navScrollBounding = navScroll.getBoundingClientRect();\n      const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n      const currentOffset = navOffset.value;\n      let newOffset = currentOffset;\n\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n        }\n\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n        }\n\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n        }\n      }\n\n      newOffset = Math.max(newOffset, 0);\n      navOffset.value = Math.min(newOffset, maxOffset);\n    };\n\n    const update = () => {\n      if (!nav$.value || !navScroll$.value) return;\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n\n      if (containerSize < navSize) {\n        const currentOffset2 = navOffset.value;\n        scrollable.value = scrollable.value || {};\n        scrollable.value.prev = currentOffset2;\n        scrollable.value.next = currentOffset2 + containerSize < navSize;\n\n        if (navSize - currentOffset2 < containerSize) {\n          navOffset.value = navSize - containerSize;\n        }\n      } else {\n        scrollable.value = false;\n\n        if (currentOffset > 0) {\n          navOffset.value = 0;\n        }\n      }\n    };\n\n    const changeTab = e => {\n      const code = e.code;\n      const {\n        up,\n        down,\n        left,\n        right\n      } = EVENT_CODE;\n      if (![up, down, left, right].includes(code)) return;\n      const tabList = Array.from(e.currentTarget.querySelectorAll(\"[role=tab]\"));\n      const currentIndex = tabList.indexOf(e.target);\n      let nextIndex;\n\n      if (code === left || code === up) {\n        if (currentIndex === 0) {\n          nextIndex = tabList.length - 1;\n        } else {\n          nextIndex = currentIndex - 1;\n        }\n      } else {\n        if (currentIndex < tabList.length - 1) {\n          nextIndex = currentIndex + 1;\n        } else {\n          nextIndex = 0;\n        }\n      }\n\n      tabList[nextIndex].focus();\n      tabList[nextIndex].click();\n      setFocus();\n    };\n\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true;\n    };\n\n    const removeFocus = () => isFocus.value = false;\n\n    watch(visibility, visibility2 => {\n      if (visibility2 === \"hidden\") {\n        focusable.value = false;\n      } else if (visibility2 === \"visible\") {\n        setTimeout(() => focusable.value = true, 50);\n      }\n    });\n    watch(focused, focused2 => {\n      if (focused2) {\n        setTimeout(() => focusable.value = true, 50);\n      } else {\n        focusable.value = false;\n      }\n    });\n    useResizeObserver(el$, update);\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0));\n    onUpdated(() => update());\n    expose({\n      scrollToActiveTab,\n      removeFocus\n    });\n    return () => {\n      const scrollBtn = scrollable.value ? [createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-prev\"), ns.is(\"disabled\", !scrollable.value.prev)],\n        \"onClick\": scrollPrev\n      }, [createVNode(ElIcon, null, {\n        default: () => [createVNode(ArrowLeft, null, null)]\n      })]), createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-next\"), ns.is(\"disabled\", !scrollable.value.next)],\n        \"onClick\": scrollNext\n      }, [createVNode(ElIcon, null, {\n        default: () => [createVNode(ArrowRight, null, null)]\n      })])] : null;\n      const tabs = props.panes.map((pane, index) => {\n        var _a, _b;\n\n        const tabName = pane.props.name || pane.index || `${index}`;\n        const closable = pane.isClosable || props.editable;\n        pane.index = `${index}`;\n        const btnClose = closable ? createVNode(ElIcon, {\n          \"class\": \"is-icon-close\",\n          \"onClick\": ev => props.onTabRemove(pane, ev)\n        }, {\n          default: () => [createVNode(Close, null, null)]\n        }) : null;\n        const tabLabelContent = ((_b = (_a = pane.instance.slots).label) == null ? void 0 : _b.call(_a)) || pane.props.label;\n        const tabindex = pane.active ? 0 : -1;\n        return createVNode(\"div\", {\n          \"ref\": `tab-${tabName}`,\n          \"class\": [ns.e(\"item\"), ns.is(rootTabs.props.tabPosition), ns.is(\"active\", pane.active), ns.is(\"disabled\", pane.props.disabled), ns.is(\"closable\", closable), ns.is(\"focus\", isFocus.value)],\n          \"id\": `tab-${tabName}`,\n          \"key\": `tab-${tabName}`,\n          \"aria-controls\": `pane-${tabName}`,\n          \"role\": \"tab\",\n          \"aria-selected\": pane.active,\n          \"tabindex\": tabindex,\n          \"onFocus\": () => setFocus(),\n          \"onBlur\": () => removeFocus(),\n          \"onClick\": ev => {\n            removeFocus();\n            props.onTabClick(pane, tabName, ev);\n          },\n          \"onKeydown\": ev => {\n            if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {\n              props.onTabRemove(pane, ev);\n            }\n          }\n        }, [...[tabLabelContent, btnClose]]);\n      });\n      return createVNode(\"div\", {\n        \"ref\": el$,\n        \"class\": [ns.e(\"nav-wrap\"), ns.is(\"scrollable\", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]\n      }, [scrollBtn, createVNode(\"div\", {\n        \"class\": ns.e(\"nav-scroll\"),\n        \"ref\": navScroll$\n      }, [createVNode(\"div\", {\n        \"class\": [ns.e(\"nav\"), ns.is(rootTabs.props.tabPosition), ns.is(\"stretch\", props.stretch && [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition))],\n        \"ref\": nav$,\n        \"style\": navStyle.value,\n        \"role\": \"tablist\",\n        \"onKeydown\": changeTab\n      }, [...[!props.type ? createVNode(TabBar, {\n        \"tabs\": [...props.panes]\n      }, null) : null, tabs]])])]);\n    };\n  }\n\n});\nexport { TabNav as default, tabNavProps };","map":{"version":3,"mappings":"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","names":["tabNavProps","buildProps","panes","type","definePropType","Array","default","mutable","currentName","String","Number","editable","Boolean","onTabClick","Function","NOOP","onTabRemove","values","stretch","COMPONENT_NAME","TabNav","defineComponent","name","props","setup","expose","throwError","ns","useNamespace","visibility","useDocumentVisibility","focused","useWindowFocus","navScroll$","ref","nav$","el$","scrollable","navOffset","isFocus","focusable","sizeName","computed","includes","rootTabs","tabPosition","navStyle","dir","value","transform","scrollPrev","containerSize","capitalize","currentOffset","newOffset","scrollNext","scrollToActiveTab","nav","activeTab","querySelector","navScroll","navScrollBounding","maxOffset","isHorizontal","offsetWidth","activeTabBounding","right","top","bottom","Math","update","navSize","prev","currentOffset2","next","e","up","changeTab","EVENT_CODE","down","left","tabList","code","nextIndex","currentTarget","currentIndex","click","setFocus","watch","focus","setTimeout","_createVNode","onMounted","tabs","removeFocus","closable","pane","scrollBtn","index","tabName","btnClose","ev","tabindex","tabLabelContent","TabBar"],"sources":["../../../../../../packages/components/tabs/src/tab-nav.tsx"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  inject,\n  onMounted,\n  onUpdated,\n  ref,\n  watch,\n} from 'vue'\nimport { NOOP } from '@vue/shared'\nimport {\n  useDocumentVisibility,\n  useResizeObserver,\n  useWindowFocus,\n} from '@vueuse/core'\nimport {\n  buildProps,\n  capitalize,\n  definePropType,\n  mutable,\n  throwError,\n} from '@element-plus/utils'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { ElIcon } from '@element-plus/components/icon'\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue'\nimport { tabsRootContextKey } from '@element-plus/tokens'\nimport { useNamespace } from '@element-plus/hooks'\nimport TabBar from './tab-bar.vue'\nimport type { CSSProperties, ExtractPropTypes } from 'vue'\nimport type { TabsPaneContext } from '@element-plus/tokens'\nimport type { TabPanelName } from './tabs'\n\ninterface Scrollable {\n  next?: boolean\n  prev?: number\n}\n\nexport const tabNavProps = buildProps({\n  panes: {\n    type: definePropType<TabsPaneContext[]>(Array),\n    default: () => mutable([] as const),\n  },\n  currentName: {\n    type: [String, Number],\n    default: '',\n  },\n  editable: Boolean,\n  onTabClick: {\n    type: definePropType<\n      (tab: TabsPaneContext, tabName: TabPanelName, ev: Event) => void\n    >(Function),\n    default: NOOP,\n  },\n  onTabRemove: {\n    type: definePropType<(tab: TabsPaneContext, ev: Event) => void>(Function),\n    default: NOOP,\n  },\n  type: {\n    type: String,\n    values: ['card', 'border-card', ''],\n    default: '',\n  },\n  stretch: Boolean,\n} as const)\n\nexport type TabNavProps = ExtractPropTypes<typeof tabNavProps>\n\nconst COMPONENT_NAME = 'ElTabNav'\nconst TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n\n  setup(props, { expose }) {\n    const rootTabs = inject(tabsRootContextKey)\n    if (!rootTabs) throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`)\n\n    const ns = useNamespace('tabs')\n    const visibility = useDocumentVisibility()\n    const focused = useWindowFocus()\n\n    const navScroll$ = ref<HTMLDivElement>()\n    const nav$ = ref<HTMLDivElement>()\n    const el$ = ref<HTMLDivElement>()\n\n    const scrollable = ref<false | Scrollable>(false)\n    const navOffset = ref(0)\n    const isFocus = ref(false)\n    const focusable = ref(true)\n\n    const sizeName = computed(() =>\n      ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n        ? 'width'\n        : 'height'\n    )\n    const navStyle = computed<CSSProperties>(() => {\n      const dir = sizeName.value === 'width' ? 'X' : 'Y'\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`,\n      }\n    })\n\n    const scrollPrev = () => {\n      if (!navScroll$.value) return\n\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (!currentOffset) return\n\n      const newOffset =\n        currentOffset > containerSize ? currentOffset - containerSize : 0\n\n      navOffset.value = newOffset\n    }\n\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (navSize - currentOffset <= containerSize) return\n\n      const newOffset =\n        navSize - currentOffset > containerSize * 2\n          ? currentOffset + containerSize\n          : navSize - containerSize\n\n      navOffset.value = newOffset\n    }\n\n    const scrollToActiveTab = () => {\n      const nav = nav$.value\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return\n\n      const activeTab = el$.value.querySelector('.is-active')\n      if (!activeTab) return\n\n      const navScroll = navScroll$.value\n      const isHorizontal = ['top', 'bottom'].includes(\n        rootTabs.props.tabPosition\n      )\n      const activeTabBounding = activeTab.getBoundingClientRect()\n      const navScrollBounding = navScroll.getBoundingClientRect()\n      const maxOffset = isHorizontal\n        ? nav.offsetWidth - navScrollBounding.width\n        : nav.offsetHeight - navScrollBounding.height\n      const currentOffset = navOffset.value\n      let newOffset = currentOffset\n\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset =\n            currentOffset - (navScrollBounding.left - activeTabBounding.left)\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset =\n            currentOffset + activeTabBounding.right - navScrollBounding.right\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset =\n            currentOffset - (navScrollBounding.top - activeTabBounding.top)\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset =\n            currentOffset +\n            (activeTabBounding.bottom - navScrollBounding.bottom)\n        }\n      }\n      newOffset = Math.max(newOffset, 0)\n      navOffset.value = Math.min(newOffset, maxOffset)\n    }\n\n    const update = () => {\n      if (!nav$.value || !navScroll$.value) return\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (containerSize < navSize) {\n        const currentOffset = navOffset.value\n        scrollable.value = scrollable.value || {}\n        scrollable.value.prev = currentOffset\n        scrollable.value.next = currentOffset + containerSize < navSize\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize\n        }\n      } else {\n        scrollable.value = false\n        if (currentOffset > 0) {\n          navOffset.value = 0\n        }\n      }\n    }\n\n    const changeTab = (e: KeyboardEvent) => {\n      const code = e.code\n\n      const { up, down, left, right } = EVENT_CODE\n      if (![up, down, left, right].includes(code)) return\n\n      // 左右上下键更换tab\n      const tabList = Array.from(\n        (e.currentTarget as HTMLDivElement).querySelectorAll<HTMLDivElement>(\n          '[role=tab]'\n        )\n      )\n      const currentIndex = tabList.indexOf(e.target as HTMLDivElement)\n\n      let nextIndex: number\n      if (code === left || code === up) {\n        // left\n        if (currentIndex === 0) {\n          // first\n          nextIndex = tabList.length - 1\n        } else {\n          nextIndex = currentIndex - 1\n        }\n      } else {\n        // right\n        if (currentIndex < tabList.length - 1) {\n          // not last\n          nextIndex = currentIndex + 1\n        } else {\n          nextIndex = 0\n        }\n      }\n      tabList[nextIndex].focus() // 改变焦点元素\n      tabList[nextIndex].click() // 选中下一个tab\n      setFocus()\n    }\n\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true\n    }\n    const removeFocus = () => (isFocus.value = false)\n\n    watch(visibility, (visibility) => {\n      if (visibility === 'hidden') {\n        focusable.value = false\n      } else if (visibility === 'visible') {\n        setTimeout(() => (focusable.value = true), 50)\n      }\n    })\n    watch(focused, (focused) => {\n      if (focused) {\n        setTimeout(() => (focusable.value = true), 50)\n      } else {\n        focusable.value = false\n      }\n    })\n\n    useResizeObserver(el$, update)\n\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0))\n    onUpdated(() => update())\n\n    expose({\n      scrollToActiveTab,\n      removeFocus,\n    })\n\n    return () => {\n      const scrollBtn = scrollable.value\n        ? [\n            <span\n              class={[\n                ns.e('nav-prev'),\n                ns.is('disabled', !scrollable.value.prev),\n              ]}\n              onClick={scrollPrev}\n            >\n              <ElIcon>\n                <ArrowLeft />\n              </ElIcon>\n            </span>,\n            <span\n              class={[\n                ns.e('nav-next'),\n                ns.is('disabled', !scrollable.value.next),\n              ]}\n              onClick={scrollNext}\n            >\n              <ElIcon>\n                <ArrowRight />\n              </ElIcon>\n            </span>,\n          ]\n        : null\n\n      const tabs = props.panes.map((pane, index) => {\n        const tabName = pane.props.name || pane.index || `${index}`\n        const closable: boolean = pane.isClosable || props.editable\n        pane.index = `${index}`\n\n        const btnClose = closable ? (\n          <ElIcon\n            class=\"is-icon-close\"\n            // @ts-expect-error native event\n            onClick={(ev: MouseEvent) => props.onTabRemove(pane, ev)}\n          >\n            <Close />\n          </ElIcon>\n        ) : null\n\n        const tabLabelContent =\n          pane.instance.slots.label?.() || pane.props.label\n        const tabindex = pane.active ? 0 : -1\n\n        return (\n          <div\n            ref={`tab-${tabName}`}\n            class={[\n              ns.e('item'),\n              ns.is(rootTabs.props.tabPosition),\n              ns.is('active', pane.active),\n              ns.is('disabled', pane.props.disabled),\n              ns.is('closable', closable),\n              ns.is('focus', isFocus.value),\n            ]}\n            id={`tab-${tabName}`}\n            key={`tab-${tabName}`}\n            aria-controls={`pane-${tabName}`}\n            role=\"tab\"\n            aria-selected={pane.active}\n            tabindex={tabindex}\n            onFocus={() => setFocus()}\n            onBlur={() => removeFocus()}\n            onClick={(ev: MouseEvent) => {\n              removeFocus()\n              props.onTabClick(pane, tabName, ev)\n            }}\n            onKeydown={(ev: KeyboardEvent) => {\n              if (\n                closable &&\n                (ev.code === EVENT_CODE.delete ||\n                  ev.code === EVENT_CODE.backspace)\n              ) {\n                props.onTabRemove(pane, ev)\n              }\n            }}\n          >\n            {...[tabLabelContent, btnClose]}\n          </div>\n        )\n      })\n\n      return (\n        <div\n          ref={el$}\n          class={[\n            ns.e('nav-wrap'),\n            ns.is('scrollable', !!scrollable.value),\n            ns.is(rootTabs.props.tabPosition),\n          ]}\n        >\n          {scrollBtn}\n          <div class={ns.e('nav-scroll')} ref={navScroll$}>\n            <div\n              class={[\n                ns.e('nav'),\n                ns.is(rootTabs.props.tabPosition),\n                ns.is(\n                  'stretch',\n                  props.stretch &&\n                    ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n                ),\n              ]}\n              ref={nav$}\n              style={navStyle.value}\n              role=\"tablist\"\n              onKeydown={changeTab}\n            >\n              {...[\n                !props.type ? <TabBar tabs={[...props.panes]} /> : null,\n                tabs,\n              ]}\n            </div>\n          </div>\n        </div>\n      )\n    }\n  },\n})\n\nexport type TabNavInstance = InstanceType<typeof TabNav>\nexport default TabNav\n"]},"metadata":{},"sourceType":"module"}