{"ast":null,"code":"import { shallowRef, onMounted, onBeforeUnmount, onUpdated, watch } from 'vue';\nimport '../../../../utils/index.mjs';\nimport '../../../../constants/index.mjs';\nimport '../../../../hooks/index.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { on, off } from '../../../../utils/dom/event.mjs';\nimport { EVENT_CODE } from '../../../../constants/aria.mjs';\n\nfunction useKeydown({\n  el$\n}, store) {\n  const ns = useNamespace(\"tree\");\n  const treeItems = shallowRef([]);\n  const checkboxItems = shallowRef([]);\n  onMounted(() => {\n    initTabIndex();\n    on(el$.value, \"keydown\", handleKeydown);\n  });\n  onBeforeUnmount(() => {\n    off(el$.value, \"keydown\", handleKeydown);\n  });\n  onUpdated(() => {\n    treeItems.value = Array.from(el$.value.querySelectorAll(\"[role=treeitem]\"));\n    checkboxItems.value = Array.from(el$.value.querySelectorAll(\"input[type=checkbox]\"));\n  });\n  watch(checkboxItems, val => {\n    val.forEach(checkbox => {\n      checkbox.setAttribute(\"tabindex\", \"-1\");\n    });\n  });\n\n  const handleKeydown = ev => {\n    const currentItem = ev.target;\n    if (!currentItem.className.includes(ns.b(\"node\"))) return;\n    const code = ev.code;\n    treeItems.value = Array.from(el$.value.querySelectorAll(`.${ns.is(\"focusable\")}[role=treeitem]`));\n    const currentIndex = treeItems.value.indexOf(currentItem);\n    let nextIndex;\n\n    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {\n      ev.preventDefault();\n\n      if (code === EVENT_CODE.up) {\n        nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.value.length - 1;\n        const startIndex = nextIndex;\n\n        while (true) {\n          if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus) break;\n          nextIndex--;\n\n          if (nextIndex === startIndex) {\n            nextIndex = -1;\n            break;\n          }\n\n          if (nextIndex < 0) {\n            nextIndex = treeItems.value.length - 1;\n          }\n        }\n      } else {\n        nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.value.length - 1 ? currentIndex + 1 : 0;\n        const startIndex = nextIndex;\n\n        while (true) {\n          if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus) break;\n          nextIndex++;\n\n          if (nextIndex === startIndex) {\n            nextIndex = -1;\n            break;\n          }\n\n          if (nextIndex >= treeItems.value.length) {\n            nextIndex = 0;\n          }\n        }\n      }\n\n      nextIndex !== -1 && treeItems.value[nextIndex].focus();\n    }\n\n    if ([EVENT_CODE.left, EVENT_CODE.right].includes(code)) {\n      ev.preventDefault();\n      currentItem.click();\n    }\n\n    const hasInput = currentItem.querySelector('[type=\"checkbox\"]');\n\n    if ([EVENT_CODE.enter, EVENT_CODE.space].includes(code) && hasInput) {\n      ev.preventDefault();\n      hasInput.click();\n    }\n  };\n\n  const initTabIndex = () => {\n    var _a;\n\n    treeItems.value = Array.from(el$.value.querySelectorAll(`.${ns.is(\"focusable\")}[role=treeitem]`));\n    checkboxItems.value = Array.from(el$.value.querySelectorAll(\"input[type=checkbox]\"));\n    const checkedItem = el$.value.querySelectorAll(`.${ns.is(\"checked\")}[role=treeitem]`);\n\n    if (checkedItem.length) {\n      checkedItem[0].setAttribute(\"tabindex\", \"0\");\n      return;\n    }\n\n    (_a = treeItems.value[0]) == null ? void 0 : _a.setAttribute(\"tabindex\", \"0\");\n  };\n}\n\nexport { useKeydown };","map":{"version":3,"mappings":"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","names":["useKeydown","el$","store","ns","useNamespace","treeItems","shallowRef","checkboxItems","onMounted","initTabIndex","on","value","handleKeydown","onBeforeUnmount","off","onUpdated","Array","from","querySelectorAll","watch","val","forEach","checkbox","setAttribute","ev","currentItem","target","className","includes","b","code","is","currentIndex","indexOf","nextIndex","EVENT_CODE","up","down","preventDefault","length","startIndex","getNode","dataset","key","canFocus","focus","left","right","click","hasInput","querySelector","enter","space","_a","checkedItem"],"sources":["../../../../../../../packages/components/tree/src/model/useKeydown.ts"],"sourcesContent":["import { onBeforeUnmount, onMounted, onUpdated, shallowRef, watch } from 'vue'\nimport { off, on } from '@element-plus/utils'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { useNamespace } from '@element-plus/hooks'\nimport type TreeStore from './tree-store'\n\nimport type { Ref } from 'vue'\nimport type { Nullable } from '@element-plus/utils'\n\ninterface UseKeydownOption {\n  el$: Ref<HTMLElement>\n}\nexport function useKeydown({ el$ }: UseKeydownOption, store: Ref<TreeStore>) {\n  const ns = useNamespace('tree')\n\n  const treeItems = shallowRef<Nullable<HTMLElement>[]>([])\n  const checkboxItems = shallowRef<Nullable<HTMLElement>[]>([])\n\n  onMounted(() => {\n    initTabIndex()\n    on(el$.value, 'keydown', handleKeydown)\n  })\n\n  onBeforeUnmount(() => {\n    off(el$.value, 'keydown', handleKeydown)\n  })\n\n  onUpdated(() => {\n    treeItems.value = Array.from(el$.value.querySelectorAll('[role=treeitem]'))\n    checkboxItems.value = Array.from(\n      el$.value.querySelectorAll('input[type=checkbox]')\n    )\n  })\n\n  watch(checkboxItems, (val) => {\n    val.forEach((checkbox) => {\n      checkbox.setAttribute('tabindex', '-1')\n    })\n  })\n\n  const handleKeydown = (ev: KeyboardEvent): void => {\n    const currentItem = ev.target as HTMLElement\n    if (!currentItem.className.includes(ns.b('node'))) return\n    const code = ev.code\n    treeItems.value = Array.from(\n      el$.value.querySelectorAll(`.${ns.is('focusable')}[role=treeitem]`)\n    )\n    const currentIndex = treeItems.value.indexOf(currentItem)\n    let nextIndex\n    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {\n      ev.preventDefault()\n      if (code === EVENT_CODE.up) {\n        nextIndex =\n          currentIndex === -1\n            ? 0\n            : currentIndex !== 0\n            ? currentIndex - 1\n            : treeItems.value.length - 1\n        const startIndex = nextIndex\n        while (true) {\n          if (\n            store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus\n          )\n            break\n          nextIndex--\n          if (nextIndex === startIndex) {\n            nextIndex = -1\n            break\n          }\n          if (nextIndex < 0) {\n            nextIndex = treeItems.value.length - 1\n          }\n        }\n      } else {\n        nextIndex =\n          currentIndex === -1\n            ? 0\n            : currentIndex < treeItems.value.length - 1\n            ? currentIndex + 1\n            : 0\n        const startIndex = nextIndex\n        while (true) {\n          if (\n            store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus\n          )\n            break\n          nextIndex++\n          if (nextIndex === startIndex) {\n            nextIndex = -1\n            break\n          }\n          if (nextIndex >= treeItems.value.length) {\n            nextIndex = 0\n          }\n        }\n      }\n      nextIndex !== -1 && treeItems.value[nextIndex].focus()\n    }\n    if ([EVENT_CODE.left, EVENT_CODE.right].includes(code)) {\n      ev.preventDefault()\n      currentItem.click()\n    }\n    const hasInput = currentItem.querySelector(\n      '[type=\"checkbox\"]'\n    ) as Nullable<HTMLInputElement>\n    if ([EVENT_CODE.enter, EVENT_CODE.space].includes(code) && hasInput) {\n      ev.preventDefault()\n      hasInput.click()\n    }\n  }\n\n  const initTabIndex = (): void => {\n    treeItems.value = Array.from(\n      el$.value.querySelectorAll(`.${ns.is('focusable')}[role=treeitem]`)\n    )\n    checkboxItems.value = Array.from(\n      el$.value.querySelectorAll('input[type=checkbox]')\n    )\n    const checkedItem = el$.value.querySelectorAll(\n      `.${ns.is('checked')}[role=treeitem]`\n    )\n    if (checkedItem.length) {\n      checkedItem[0].setAttribute('tabindex', '0')\n      return\n    }\n    treeItems.value[0]?.setAttribute('tabindex', '0')\n  }\n}\n"]},"metadata":{},"sourceType":"module"}